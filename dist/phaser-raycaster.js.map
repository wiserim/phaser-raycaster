{"version":3,"file":"phaser-raycaster.js","mappings":"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G,KAAK;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAClG,MAAM,GAAG,KAAK;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACjB,MAAM;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACoC,OAAO,GAAG,EAAE;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkC,SAAS,GAAG,EAAE;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACxD,SAAS;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,WAAW;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAChB,cAAc;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,SAAS;EAEd,IAAI,CAACL,MAAM,CAAClB,OAAO,CAAC;EACpB,IAAG,CAAC,IAAI,CAACkC,YAAY,EACjB,IAAI,CAACX,SAAS,EAAE;EAEpB,OAAO,IAAI;AACf;AAAC;AAEDiG,GAAG,CAACG,SAAS,GAAG;EACZzG,MAAM,EAAEpB,sEAA6B;EACrCuC,OAAO,EAAEvC,yEAA+B;EACxC,IAAIqC,OAAO,GAAG;IACV,OAAO,IAAI,CAACuF,QAAQ;EACxB,CAAC;EACD,IAAIvF,OAAO,CAACA,OAAO,EAAE;IACjB,IAAG,IAAI,CAACuF,QAAQ,IAAIvF,OAAO,EACvB,OAAO,IAAI;IAEf,IAAGA,OAAO,EAAE;MACR,IAAI,CAACuF,QAAQ,GAAG,IAAI;;MAEpB;MACA,IAAG,IAAI,CAACpC,UAAU,EAAE;QAChB,IAAI,CAACA,UAAU,CAACsC,oBAAoB,CAAChD,IAAI,CAAC,IAAI,CAACrE,MAAM,CAAC;QAEtD,IAAI,CAAC+E,UAAU,CAACuC,MAAM,CAACC,aAAa,CAAC3F,OAAO,GAAG,IAAI,CAACmD,UAAU,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A;AACA;AACA;AACA;AACO,SAASC,GAAG,CAACzV,OAAO,EAAEyH,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACnC,UAAU,GAAGmC,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACvD,MAAM,GAAG,IAAIjE,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC6I,IAAI,GAAG,IAAI5L,MAAM,CAAC8C,IAAI,CAACS,IAAI,EAAE;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,KAAK,GAAG,CAAC;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACyK,IAAI,GAAG,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACpD,QAAQ,GAAG7L,MAAM,CAACmE,IAAI,CAAC8F,gBAAgB;EAC5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACD,cAAc,GAAG,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACK,oBAAoB,GAAG,IAAIrK,MAAM,CAAC8C,IAAI,CAACuE,MAAM,EAAE;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACwI,cAAc,GAAG7P,MAAM,CAACmE,IAAI,CAAC8F,gBAAgB;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC0D,wBAAwB,GAAG,IAAI;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,KAAK,GAAG,KAAK;EAClB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,SAAS,GAAG,KAAK;EACtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC9B,aAAa,GAAG,EAAE;EACvB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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS9H,SAAS,CAACC,OAAO,EAAE;EAC/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC8V,OAAO,GAAG,QAAQ;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACnW,KAAK;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACuQ,QAAQ;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACF,YAAY,GAAG;IAChBC,OAAO,EAAE,KAAK;IACdhC,IAAI,EAAE,IAAI;IACVrB,IAAI,EAAE,IAAI;IACVsD,QAAQ,EAAE;MACNxN,GAAG,EAAE,QAAQ;MACbgO,QAAQ,EAAE,QAAQ;MAClBqF,QAAQ,EAAE,QAAQ;MAClBC,UAAU,EAAE,QAAQ;MACpBC,cAAc,EAAE;IACpB;EACJ,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACK,IAAI,CAACpO,MAAM,GAAG;IACXC,aAAa,EAAE;MACXE,KAAK,EAAE,CAAC;MACRD,MAAM,EAAE,CAAC;MACT5F,OAAO,EAAE,CAAC;MACV+T,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAE,CAAC;MACdC,UAAU,EAAE,CAAC;MACbC,QAAQ,EAAE,CAAC;MACXC,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAE,CAAC;MACdC,UAAU,EAAE;IAChB;EACH,CAAC;;EAEF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACvV,WAAW,GAAG,KAAK;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC6G,aAAa,GAAG,EAAE;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;EACK,IAAI,CAACF,oBAAoB,GAAG,EAA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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/before-startup","webpack://PhaserRaycaster/webpack/startup","webpack://PhaserRaycaster/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\n* @copyright    2022 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n/**\n * Point object\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n */\n \n/**\n * @classdesc\n *\n * Raycaster plugin class.\n * \n * @namespace PhaserRaycaster\n * @class PhaserRaycaster\n * @extends Phaser.Plugins.ScenePlugin\n * @constructor\n * @since 6.0.0\n *\n * @param {Phaser.Scene} scene\n * @param {Phaser.Plugins.PluginManager} pluginManager\n */\n\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\n    }\n\n    /**\n    * Create Raycaster object.\n    *\n    * @method PhaserRaycaster#createRaycaster\n    * @memberof PhaserRaycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    createRaycaster(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n}\n\n//Make sure you export the plugin for webpack to expose\nmodule.exports = PhaserRaycaster;","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            //container's child\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            //transformed container's circle children\n            this._circles = [];\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            this._updateChildMap = container._updateChildMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //if object is not supported\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\n        this.notSupported = true;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n* @param {boolean} [isChild] - Flag definig if it is child container.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, isChild = false) {\n    if(!this.active)\n        return [];\n\n    let points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(this.segmentCount == 0 && !isChild) {\n        if(ray) {\n            //create temporary ray\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n    \n            let tempRay = ray._raycaster.createRay({\n                origin: {\n                    x: vector.getPointB().x,\n                    y: vector.getPointB().y\n                }\n            });\n\n            //calculate tangent rays\n            let rayA = new Phaser.Geom.Line();\n            let rayB = new Phaser.Geom.Line();\n            let c;\n\n            for(let circle of this._circles) {\n                circle.points = [];\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\n\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\n\n                //ray angle\n                let angle = Phaser.Geom.Line.Angle(c);\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n                //adding tangent points\n                circle.points.push(rayA.getPointB());\n                circle.points.push(rayB.getPointB());\n                points.push(rayA.getPointB());\n                points.push(rayB.getPointB());\n            }\n        }\n    }\n    \n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n    this._circles = [];\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    if(this.mapChild) {\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\n    }\n    else {\n        //iterate through container's children\n        container.iterate(function(child){\n            this._updateChildMap(child, points, segments, rotation, offset);\n        }.bind(this));\n\n        //get children intersections\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\n            let childA = container.list[i];\n            let mapA = childA.data.get('raycasterMap');\n            \n            if(!mapA)\n                continue;\n\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n                let childB = container.list[j];\n                let mapB = childB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                    continue;\n\n                //find objects intersections\n                for(let segmentA of mapA.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        //calculate positions after container's rotation\n                        if(rotation !== 0) {\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                            points.push(vector.getPointB());\n                        }\n                        //if rotation === 0\n                        else\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                    }\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n\n/**\n* Update container's child map of points and segments.\n*\n* @method Raycaster.Map#container._updateChildMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.10.3\n*\n* @param {object} [child] - Container's child object.\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\n* @param {number} [rotation] - Container's rotation.\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\n*/\nexport function _updateChildMap(child, points, segments, rotation, offset) {\n    if(!child.data)\n        child.setDataEnabled();\n\n    //if object is not supported\n    if(child.data.get('raycasterMapNotSupported'))\n        return;\n\n    //get child map\n    let map = child.data.get('raycasterMap');\n    if(!map) {\n        map = new this.constructor({\n            object: child,\n            segmentCount: this.segmentCount\n        });\n\n        if(map.notSupported) {\n            map.destroy();\n            child.data.set('raycasterMapNotSupported', true);\n            return;\n        }\n\n        child.data.set('raycasterMap', map);\n    }\n    else\n        map.updateMap();\n\n    //add child points\n    let childPoints = [];\n    for(let point of map.getPoints(false, true)) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n        //if rotation === 0\n        else\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n\n        childPoints.push(points[points.length - 1])\n    }\n\n    //add child segments\n    for(let segment of map.getSegments()) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let pointA = segment.getPointA();\n            let pointB = segment.getPointB();\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n        }\n        //if rotation === 0\n        else\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\n    }\n\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\n    if(map.type == 'Arc' && this.segmentCount == 0) {\n        let circleOffset = new Phaser.Geom.Point();\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\n\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            circleOffset = vector.getPointB();\n        }\n\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\n    }\n    else if(map.type === 'Container') {\n        for(let childMapCircle of map._circles) {\n            let circleOffset = new Phaser.Geom.Point();\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\n\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                circleOffset = vector.getPointB();\n            }\n\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\n        }\n    }\n}\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map_dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this._dynamic = false;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    if(!this.notSupported)\n        this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config,\n    destroy: require('./destroy.js').destroy,\n    get dynamic() {\n        return this._dynamic;\n    },\n    set dynamic(dynamic) {\n        if(this._dynamic == dynamic)\n            return this;\n    \n        if(dynamic) {\n            this._dynamic = true;\n            \n            //add object to raycaster's dynamic objects list\n            if(this._raycaster) {\n                this._raycaster.dynamicMappedObjects.push(this.object);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n        else {\n            this._dynamic = false;\n            \n            //remove object from reycasters' dynamic objects list\n            if(this._raycaster) {\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\n                if(index >= 0)\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n    \n        return this;\n     }\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {number} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {number} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox).length === 0)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n\n        //check container map's circles\n        if(map.type == 'Container' && map._circles.length > 0) {\n            for(let circle of map._circles) {\n                //check if target point is a circle tangent point to ray\n                if(options.target) {\n                    let isTangent = false;\n\n                    for(let point of circle.points) {\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\n                            //get closest intersection\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                            if(distance < closestDistance) {\n                                closestDistance = distance;\n                                closestIntersection = point;\n                                closestObject = map.object;\n                                isTangent = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(isTangent)\n                        continue;\n                }\n\n                let circleIntersections = [];\n\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                    for(let intersection of circleIntersections) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = intersection;\n                            closestObject = map.object;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    rayTargets.push({\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    });\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            \n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCone',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {number}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {number}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {number}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(boolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug,\n    destroy: require('./destroy.js').destroy,\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n * @param {number} [angle] - Ray's angle in radians.\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2022 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.11.0';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.11.0\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1);\r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                object.raycasterMap.destroy();\r\n            else\r\n                object.data.get('raycasterMap').destroy();\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n\r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.js\");\n",""],"names":["PhaserRaycaster","scene","pluginManager","_Raycaster","require","Raycaster","options","Phaser","Plugins","ScenePlugin","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","undefined","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","key","ray","_points","length","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","isChild","tempRay","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","childMapCircle","Map","raycaster","_dynamic","prototype","dynamicMappedObjects","_stats","mappedObjects","static","total","index","indexOf","splice","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","find","segmentIndex","findIndex","x1","y1","x2","y2","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","_boundingBox","setTo","Equals","isTangent","circleIntersections","GetLineToCircle","result","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","value","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","version","mapPoint","mapSegment","mapBoundingBox","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","enableMaps","disableMaps","mapppedObject","strokeRectShape"],"sourceRoot":""}