{"version":3,"file":"phaser-raycaster.js","mappings":"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CX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC2G,QAAQ,GAAG,KAAK;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACvH,MAAM,GAAG,KAAK;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAChB,MAAM;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkC,OAAO,GAAG,EAAE;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkC,SAAS,GAAG,EAAE;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACvD,SAAS;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,WAAW;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACf,cAAc;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACgB,SAAS;EAEd,IAAI,CAACJ,MAAM,CAACrB,OAAO,CAAC;EACpB,IAAG,CAAC,IAAI,CAACoC,YAAY,EACjB,IAAI,CAACX,SAAS,CAAC,CAAC;EAEpB,OAAO,IAAI;AACf;AAAC;AAEDqH,GAAG,CAACI,SAAS,GAAG;EACZ7H,MAAM,EAAE5B,sEAA6B;EACrC8C,OAAO,EAAE9C,yEAA+B;EACxC,IAAI4C,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAAC4G,QAAQ;EACxB,CAAC;EACD,IAAI5G,OAAOA,CAACA,OAAO,EAAE;IACjB,IAAG,IAAI,CAAC4G,QAAQ,IAAI5G,OAAO,EACvB,OAAO,IAAI;IAEf,IAAGA,OAAO,EAAE;MACR,IAAI,CAAC4G,QAAQ,GAAG,IAAI;;MAEpB;MACA,IAAG,IAAI,CAACD,UAAU,EAAE;QAChB,IAAI,CAACA,UAAU,CAACG,oBAAoB,CAACvE,IAAI,CAAC,IAAI,CAAClE,MAAM,CAAC;QAEtD,IA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;EAEf,OAAO,KAAK;AAChB;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,GAAGA,CAAC7X,OAAO,EAAE+I,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,UAAU,GAAGD,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC7E,MAAM,GAAG,IAAI9D,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkK,IAAI,GAAG,IAAI9M,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,KAAK,GAAG,CAAC;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACmN,IAAI,GAAG,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACzE,QAAQ,GAAG/M,MAAM,CAACgE,IAAI,CAACmH,gBAAgB;EAC5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACD,cAAc,GAAG,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACS,oBAAoB,GAAG,IAAI3L,MAAM,CAAC2C,IAAI,CAAC2F,MAAM,CAAC,CAAC;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC6J,cAAc,GAAGnS,MAAM,CAACgE,IAAI,CAACmH,gBAAgB;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACsE,wBAAwB,GAAG,IAAI;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,KAAK,GA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M,GAAC,CAAC,CAAC,CAAC+C,CAAC,EAAEoL,aAAa,CAACA,aAAa,CAACnO,MAAM,GAAC,CAAC,CAAC,CAACkD,CAAC,CAAC,CAAC;EAEjM,OAAO6U,MAAM;AACjB;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,SAASH,QAAQA,CAAA,EAAG;EACvB,OAAO,IAAI,CAAC1O,MAAM;AACtB;;;;;;;;;;;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS1J,SAASA,CAACM,OAAO,EAAE;EAC/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkY,OAAO,GAAG,SAAS;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC/Y,KAAK;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACwT,QAAQ;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACF,YAAY,GAAG;IAChBC,OAAO,EAAE,KAAK;IACdxC,IAAI,EAAE,IAAI;IACVjC,IAAI,EAAE,IAAI;IACV0E,QAAQ,EAAE;MACNhQ,GAAG,EAAE,QAAQ;MACbwQ,QAAQ,EAAE,QAAQ;MAClBgF,QAAQ,EAAE,QAAQ;MAClBC,UAAU,EAAE,QAAQ;MACpBC,cAAc,EAAE;IACpB;EACJ,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACK,IAAI,CAACjP,MAAM,GAAG;IACXC,aAAa,EAAE;MACXE,KAAK,EAAE,CAAC;MACRD,MAAM,EAAE,CAAC;MACTjH,OAAO,EAAE,CAAC;MACViW,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAE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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/before-startup","webpack://PhaserRaycaster/webpack/startup","webpack://PhaserRaycaster/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * Point object\r\n * @typedef {Object} Point\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n \r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster plugin class.\r\n * \r\n * @namespace PhaserRaycaster\r\n * @class PhaserRaycaster\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {Phaser.Scene} scene\r\n * @param {Phaser.Plugins.PluginManager} pluginManager\r\n */\r\n\r\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\r\n    constructor(scene, pluginManager) {\r\n        super(scene, pluginManager);\r\n\r\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\r\n    }\r\n\r\n    /**\r\n    * Create Raycaster object.\r\n    *\r\n    * @method PhaserRaycaster#createRaycaster\r\n    * @memberof PhaserRaycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    createRaycaster(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n}\r\n\r\n//Make sure you export the plugin for webpack to expose\r\nmodule.exports = PhaserRaycaster;","/**\r\n* Get mapped object's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    return this.object.getBounds();\r\n}\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\nlet matterBody = require('./map-matterBody-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet boundingBox = require('./boundingBox.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\r\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\r\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    if(options.type === 'body' || options.type === 'composite')\r\n        options.type = 'MatterBody';\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.circle = (options.segmentCount) ? false : true;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            //container's child\r\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            //transformed container's circle children\r\n            this._circles = [];\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = container.updateMap;\r\n            this._updateChildMap = container._updateChildMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'TilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'MatterBody':\r\n            //force convex body (hull) mapping\r\n            this.forceConvex = (options.forceConvex) ? true : false;\r\n            //force mapping by vertices\r\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\r\n            this.circle = false;\r\n            this.getPoints = matterBody.getPoints;\r\n            this.getSegments = matterBody.getSegments;\r\n            this.getBoundingBox = matterBody.getBoundingBox;\r\n            this.updateMap = matterBody.updateMap;\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //if object is not supported\r\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\r\n        this.notSupported = true;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete this.object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //add tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n        //assign neighbours\r\n        points[0].neighbours = [points[1]];\r\n        points[1].neighbours = [points[0]];\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n    \r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n* @param {boolean} [isChild] - Flag definig if it is child container.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, isChild = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(this.segmentCount == 0 && !isChild) {\r\n        if(ray) {\r\n            //create temporary ray\r\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n            //calculate tangent rays\r\n            let rayA = new Phaser.Geom.Line(),\r\n                rayB = new Phaser.Geom.Line(),\r\n                c;\r\n\r\n            for(let circle of this._circles) {\r\n                circle.points = [];\r\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\r\n\r\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\r\n\r\n                //ray angle\r\n                let angle = Phaser.Geom.Line.Angle(c);\r\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\r\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n                //adding tangent points\r\n                circle.points.push(rayA.getPointB());\r\n                circle.points.push(rayB.getPointB());\r\n                points.push(rayA.getPointB());\r\n                points.push(rayB.getPointB());\r\n            }\r\n        }\r\n    }\r\n    \r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n    this._circles = [];\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    if(this.mapChild) {\r\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\r\n    }\r\n    else {\r\n        //iterate through container's children\r\n        container.iterate(function(child){\r\n            this._updateChildMap(child, points, segments, rotation, offset);\r\n        }.bind(this));\r\n\r\n        //get children intersections\r\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n            let childA = container.list[i];\r\n            let mapA = childA.data.get('raycasterMap');\r\n            \r\n            if(!mapA)\r\n                continue;\r\n\r\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n                let childB = container.list[j];\r\n                let mapB = childB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                    continue;\r\n\r\n                //find objects intersections\r\n                for(let segmentA of mapA.getSegments()) {\r\n                    for(let segmentB of mapB.getSegments()) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        //calculate positions after container's rotation\r\n                        if(rotation !== 0) {\r\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\r\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                            points.push(vector.getPointB());\r\n                        }\r\n                        //if rotation === 0\r\n                        else\r\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Update container's child map of points and segments.\r\n*\r\n* @method Raycaster.Map#container._updateChildMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.10.3\r\n*\r\n* @param {object} [child] - Container's child object.\r\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\r\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\r\n* @param {number} [rotation] - Container's rotation.\r\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\r\n*/\r\nexport function _updateChildMap(child, points, segments, rotation, offset) {\r\n    if(!child.data)\r\n        child.setDataEnabled();\r\n\r\n    //if object is not supported\r\n    if(child.data.get('raycasterMapNotSupported'))\r\n        return;\r\n\r\n    //get child map\r\n    let map = child.data.get('raycasterMap');\r\n    if(!map) {\r\n        map = new this.constructor({\r\n            object: child,\r\n            segmentCount: this.segmentCount\r\n        });\r\n\r\n        if(map.notSupported) {\r\n            map.destroy();\r\n            child.data.set('raycasterMapNotSupported', true);\r\n            return;\r\n        }\r\n\r\n        child.data.set('raycasterMap', map);\r\n    }\r\n    else\r\n        map.updateMap();\r\n\r\n    //add child points\r\n    let childPoints = [];\r\n    for(let point of map.getPoints(false, true)) {\r\n        let childPoint;\r\n\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            childPoint = vector.getPointB();\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            childPoint = new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y);\r\n\r\n        //add neighbour points\r\n        childPoint.neighbours = [];\r\n        if(childPoints.length > 0) {\r\n            let previousPoint = childPoints.slice(-1)[0];\r\n            previousPoint.neighbours.push(childPoint);\r\n            childPoint.neighbours.push(previousPoint);\r\n        }\r\n        \r\n        childPoints.push(childPoint);\r\n        points.push(childPoint);\r\n    }\r\n\r\n    //add neighbour point to last child point\r\n    if(childPoints.length > 0) {\r\n        childPoints.slice(-1)[0].neighbours.push(childPoints[0]);\r\n    }\r\n\r\n    //add child segments\r\n    for(let segment of map.getSegments()) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let pointA = segment.getPointA();\r\n            let pointB = segment.getPointB();\r\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\r\n    }\r\n\r\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\r\n    if(map.type == 'Arc' && this.segmentCount == 0) {\r\n        let circleOffset = new Phaser.Geom.Point();\r\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\r\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\r\n\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            circleOffset = vector.getPointB();\r\n        }\r\n\r\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\r\n    }\r\n    else if(map.type === 'Container') {\r\n        for(let childMapCircle of map._circles) {\r\n            let circleOffset = new Phaser.Geom.Point();\r\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\r\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\r\n\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                circleOffset = vector.getPointB();\r\n            }\r\n\r\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Map#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.9.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map_dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this._dynamic = false;\r\n    /**\r\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\r\n    *\r\n    * @name Raycaster.Map#circle\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.circle = false;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Get mapped object's bounding box.\r\n    *\r\n    * @method Raycaster.Map#getBoundingBox\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.9.0\r\n    *\r\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\r\n    */\r\n    this.getBoundingBox;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n\r\n    this.config(options);\r\n    if(!this.notSupported)\r\n        this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    destroy: require('./destroy.js').destroy,\r\n    get dynamic() {\r\n        return this._dynamic;\r\n    },\r\n    set dynamic(dynamic) {\r\n        if(this._dynamic == dynamic)\r\n            return this;\r\n    \r\n        if(dynamic) {\r\n            this._dynamic = true;\r\n            \r\n            //add object to raycaster's dynamic objects list\r\n            if(this._raycaster) {\r\n                this._raycaster.dynamicMappedObjects.push(this.object);\r\n    \r\n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\r\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\r\n            }\r\n        }\r\n        else {\r\n            this._dynamic = false;\r\n            \r\n            //remove object from reycasters' dynamic objects list\r\n            if(this._raycaster) {\r\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\r\n                if(index >= 0)\r\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\r\n    \r\n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\r\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\r\n            }\r\n        }\r\n    \r\n        return this;\r\n     }\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n    //assign neighbours\r\n    points[0].neighbours = [points[1]];\r\n    points[1].neighbours = [points[0]];\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for matter body*/\r\n/**\r\n* Get array of mapped matter body's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#matterBody.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n\r\n    //calculate tangent rays\r\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\r\n        let points = [];\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB(), rayB.getPointB());\r\n\r\n        return points;\r\n    }\r\n\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped matter body's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#matterBody.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update matter body's map of points and segments.\r\n*\r\n* @method Raycaster.Map#matterBody.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n    let bodies = [body];\r\n    let generateBounds = false;\r\n\r\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\r\n        this.circle = true;\r\n        this._points = points;\r\n        this._segments = segments;\r\n\r\n        return this;\r\n    }\r\n\r\n    this.circle = false;\r\n\r\n    if(body.type == 'composite')\r\n        bodies = body.bodies;\r\n\r\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\r\n        generateBounds = true;\r\n    }\r\n    \r\n    for(let bodyItem of bodies) {\r\n        //if convex body\r\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\r\n            let vertices = bodyItem.parts[0].vertices;\r\n\r\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\r\n            points[0].neighbours = [];\r\n\r\n            for(let i = 1, length = vertices.length; i < length; i++) {\r\n                let pointA = points.slice(-1)[0],\r\n                    pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\r\n                    \r\n                if(!pointA.neighbours)\r\n                    pointA.neighbours = [];\r\n                pointA.neighbours.push(pointB);\r\n                pointB.neighbours = [pointA];\r\n\r\n                points.push(pointB);\r\n\r\n                //add segment\r\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                segments.push(segment);\r\n            }\r\n\r\n            //closing segment\r\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n            segments.push(segment);\r\n\r\n            points[0].neighbours.push(points.slice(-1)[0]);\r\n        }\r\n\r\n        //if concave body\r\n        else {\r\n            let parts = [],\r\n                indexedPoints = [];\r\n\r\n            for(let i = 1, iLength = bodyItem.parts.length; i < iLength; i++) {\r\n                let vertices = bodyItem.parts[i].vertices,\r\n                    part = [];\r\n                \r\n                for(let j = 0, jLength = vertices.length; j < jLength; j++) {\r\n                    let point = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\r\n\r\n                    if(part.length) {\r\n                        let prevPoint = part.slice(-1)[0];\r\n                        point.neighbours = [prevPoint];\r\n                        prevPoint.neighbours.push(point);\r\n                    }\r\n                    else {\r\n                        point.neighbours = [];\r\n                    }\r\n\r\n                    let index = vertices[j].x + '/' + vertices[j].y;\r\n                    if(indexedPoints[index] === undefined) {\r\n                        points.push(point);\r\n                        indexedPoints[index] = point;\r\n                    }\r\n                    else {\r\n                        indexedPoints[index].neighbours.push(point);\r\n                        point.neighbours.push(indexedPoints[index]);\r\n                    }\r\n\r\n                    part.push(point);\r\n\r\n                    if(vertices[j].isInternal) {\r\n                        parts.push(part);\r\n                        part = [];\r\n                    }\r\n                }\r\n                parts.push(part);\r\n            }\r\n\r\n            for(let part of parts) {\r\n                let i = 0,\r\n                iLength;\r\n                for(i = 0, iLength = part.length - 1; i < iLength; i++) {\r\n                    segments.push(new Phaser.Geom.Line(part[i].x, part[i].y, part[i+1].x, part[i+1].y));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    if(generateBounds) {\r\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\r\n        body.bounds = bounds;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Get matter body's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\r\n\r\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\r\n}\r\n\r\n","/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is not closed\r\n    if(!this.object.closePath) {\r\n       segments.pop();\r\n       points[0].neighbours.shift();\r\n       points[points.length - 1].neighbours.pop();\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for tilemaps*/\r\n/**\r\n* Get array of mapped tilemap's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#tilemap.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._points;\r\n\r\n    let points = [];\r\n    for(let point of this._points) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\r\n            points.push(point);\r\n    }\r\n\r\n    //get intersections between tilemap's segments and ray's detection range edge\r\n    let segments = this.getSegments(ray);\r\n\r\n    for(let segment of segments) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\r\n        \r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#tilemap.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || (ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER)))\r\n        return this._segments;\r\n\r\n    let segments = [];\r\n    for(let segment of this._segments) {\r\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\r\n            segments.push(segment);\r\n        }\r\n    }\r\n\r\n    return segments;\r\n};\r\n\r\n/**\r\n* Update tilemap's map of points and segments.\r\n*\r\n* @method Raycaster.Map#tilemap.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [],\r\n        segments = [],\r\n        columns = Array(this.object.layer.data[0].length + 1);\r\n        \r\n        for(let i = 0, iLength = columns.length; i < iLength; i++) {\r\n            columns[i] = [];\r\n        }\r\n\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point(this.object.x, this.object.y);\r\n\r\n    let row = this.object.layer.data[0],\r\n        tileWidth = this.object.layer.tileWidth * this.object.scaleX,\r\n        tileHeight = this.object.layer.tileHeight * this.object.scaleY,\r\n        startPoint,\r\n        endPoint;\r\n\r\n    //set top horizontal lines\r\n    if(this.collisionTiles.includes(row[0].index)) {\r\n        startPoint = new Phaser.Geom.Point(offset.x, offset.y);\r\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, offset.y);\r\n\r\n        columns[0].push(startPoint);\r\n    }\r\n\r\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\r\n        let tile = row[i];\r\n        \r\n        if(!this.collisionTiles.includes(tile.index)) {\r\n            if(startPoint) {\r\n                startPoint.neighbours = [endPoint];\r\n                endPoint.neighbours = [startPoint];\r\n\r\n                points.push(startPoint, endPoint);\r\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                columns[i].push(endPoint);\r\n\r\n                startPoint = false;\r\n                endPoint = false;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        let x = i * tileWidth + offset.x,\r\n            y = offset.y;\r\n\r\n        if(!startPoint) {\r\n            startPoint = new Phaser.Geom.Point(x, y);\r\n            columns[i].push(startPoint);\r\n        }\r\n\r\n        if(!endPoint) {\r\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n        }\r\n        else {\r\n            endPoint.x = x + tileWidth;\r\n        }\r\n    }\r\n\r\n    if(startPoint) {\r\n        startPoint.neighbours = [endPoint];\r\n        endPoint.neighbours = [startPoint];\r\n\r\n        points.push(startPoint, endPoint);\r\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n        columns[row.length].push(endPoint);\r\n    }\r\n\r\n    startPoint = false;\r\n    endPoint = false;\r\n\r\n    for(let i = 1, iLength = this.object.layer.data.length; i < iLength; i++) {\r\n        row = this.object.layer.data[i];\r\n        let higherRow = this.object.layer.data[i - 1];\r\n\r\n        if(this.collisionTiles.includes(row[0].index) != this.collisionTiles.includes(higherRow[0].index)) {\r\n            startPoint = new Phaser.Geom.Point(offset.x,  i * tileHeight + offset.y);\r\n            endPoint = new Phaser.Geom.Point(tileWidth + offset.x, i * tileHeight + offset.y);\r\n\r\n            columns[0].push(startPoint);\r\n        }\r\n\r\n        for(let j = 1, jLength = row.length; j < jLength; j++) {\r\n            let tile = row[j],\r\n                isCollisionTile = this.collisionTiles.includes(tile.index),\r\n                isCollisionHigherTile = this.collisionTiles.includes(higherRow[j].index);\r\n            \r\n            if(isCollisionTile == isCollisionHigherTile) {\r\n                if(startPoint) {\r\n                    startPoint.neighbours = [endPoint];\r\n                    endPoint.neighbours = [startPoint];\r\n\r\n                    points.push(startPoint, endPoint);\r\n                    segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                    columns[j].push(endPoint);\r\n\r\n                    startPoint = false;\r\n                    endPoint = false;\r\n                }\r\n                continue;\r\n            }\r\n    \r\n            let x = j * tileWidth + offset.x,\r\n                y = i * tileHeight + offset.y;\r\n    \r\n            if(!startPoint) {\r\n                startPoint = new Phaser.Geom.Point(x, y);\r\n\r\n                columns[j].push(startPoint);\r\n            }\r\n    \r\n            if(!endPoint) {\r\n                endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n            }\r\n            else {\r\n                endPoint.x = x + tileWidth;\r\n            }\r\n        }\r\n    \r\n        if(startPoint) {\r\n            startPoint.neighbours = [endPoint];\r\n            endPoint.neighbours = [startPoint];\r\n\r\n            points.push(startPoint, endPoint);\r\n            segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n            columns[row.length].push(endPoint);\r\n        }\r\n\r\n        startPoint = false;\r\n        endPoint = false;\r\n    }\r\n\r\n    //set bottom horizontal lines\r\n    row = this.object.layer.data.slice(-1)[0];\r\n    let y = this.object.layer.data.length * tileHeight + offset.y;\r\n\r\n    if(this.collisionTiles.includes(row[0].index)) {\r\n        startPoint = new Phaser.Geom.Point(offset.x, y);\r\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, y);\r\n\r\n        columns[0].push(startPoint);\r\n    }\r\n\r\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\r\n        let tile = row[i];\r\n        \r\n        if(!this.collisionTiles.includes(tile.index)) {\r\n            if(startPoint) {\r\n                startPoint.neighbours = [endPoint];\r\n                endPoint.neighbours = [startPoint];\r\n\r\n                points.push(startPoint, endPoint);\r\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                columns[i].push(endPoint);\r\n\r\n                startPoint = false;\r\n                endPoint = false;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        let x = i * tileWidth + offset.x;\r\n\r\n        if(!startPoint) {\r\n            startPoint = new Phaser.Geom.Point(x, y);\r\n\r\n            columns[i].push(startPoint);\r\n        }\r\n\r\n        if(!endPoint) {\r\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n        }\r\n        else {\r\n            endPoint.x = x + tileWidth;\r\n        }\r\n    }\r\n\r\n    if(startPoint) {\r\n        startPoint.neighbours = [endPoint];\r\n        endPoint.neighbours = [startPoint];\r\n\r\n        points.push(startPoint, endPoint);\r\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n        columns[row.length].push(endPoint);\r\n    }\r\n\r\n    //set vertical lines\r\n    for(let i = 0, iLength = columns.length; i < iLength; i++) {\r\n        const column = columns[i];\r\n\r\n        for(let j = 0, jLength = column.length - 1; j < jLength; j++) {\r\n            segments.push(new Phaser.Geom.Line(column[j].x, column[j].y, column[j+1].x, column[j+1].y));\r\n            column[j].neighbours.push(column[j+1]);\r\n            column[j+1].neighbours.push(column[j]);\r\n            j++;\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n\r\n/**\r\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\r\n*\r\n* @method Raycaster.Map#setCollisionTiles\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @since 0.7.3\r\n*\r\n* @param {array} [tiles = []] - Set of tile's indexes to map.\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function setCollisionTiles(tiles = []) {\r\n    this.collisionTiles = tiles;\r\n    return this;\r\n}\r\n","/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n    this.circle = count ? false : true;\r\n\r\n    this.updateMap();\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n","/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestSegment;\r\n    let closestObject;\r\n    let closestDistance = this.rayRange;\r\n    let internal = options.internal ? options.internal : false;\r\n    let startTime = performance.now();\r\n    let stats = {\r\n        method: 'cast',\r\n        rays: 1,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        let map, boundingBox, boundingBoxIntersections = [], canTestMap = false;\r\n        \r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        stats.testedMappedObjects++;\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        if(internal) {\r\n            boundingBox = map._boundingBox;\r\n        }\r\n        else {\r\n            boundingBox = map.getBoundingBox();\r\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n        }\r\n\r\n        //check if object is intersected by ray\r\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0)\r\n            continue;\r\n\r\n        //check if bounding box is closer than closest intersection\r\n        if(Phaser.Geom.Rectangle.ContainsPoint(boundingBox, this.origin)) {\r\n            canTestMap = true;\r\n        }\r\n        else {\r\n            for(let boundingBoxIntersection of boundingBoxIntersections) {\r\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) < closestDistance) {\r\n                    canTestMap = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!canTestMap)\r\n            continue;\r\n\r\n        stats.hitMappedObjects++;\r\n        stats.segments += map.getSegments(this).length;\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n                closestObject = map.object;\r\n                closestSegment = segment;\r\n            }\r\n        }\r\n\r\n        //check if map is circular\r\n        if(map.circle) {\r\n           //if circular map has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            closestObject = map.object;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                        closestObject = map.object;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //check container map's circles\r\n        if(map.type == 'Container' && map._circles.length > 0) {\r\n            for(let circle of map._circles) {\r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let isTangent = false;\r\n\r\n                    for(let point of circle.points) {\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                closestObject = map.object;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                            closestObject = map.object;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //update stats\r\n    if(internal) {\r\n        this._stats.rays++;\r\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\r\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\r\n        this._stats.segments += stats.segments;\r\n    }\r\n    else {\r\n        stats.time = performance.now() - startTime;\r\n        this._stats = stats;\r\n    }\r\n\r\n    let result;\r\n    if(!closestIntersection) {\r\n        if(this.ignoreNotIntersectedRays)\r\n            return false;\r\n\r\n        result = this._ray.getPointB();\r\n    }\r\n    else {\r\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n        result.segment = closestSegment;\r\n        result.object = closestObject;\r\n    }\r\n\r\n    if(this.round) {\r\n        result.x = Math.round(result.x);\r\n        result.y = Math.round(result.y);\r\n    }\r\n\r\n    if(!internal)\r\n        this.drawDebug([result]);\r\n    \r\n    return result;\r\n}","/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCircle',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else {\r\n                mapB = objectB.data.get('raycasterMap');\r\n            }\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                    let target = {\r\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                    };\r\n                    target.point.intersection = false;\r\n                    rayTargets.push(target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angle - b.angle;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n\r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection) {\r\n            //if intersection hits target point check if ray \"glanced\" mapped object.\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n\r\n            if(!castSides) {\r\n                //castSides = false;\r\n            }\r\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray and at least one line between target point and it's neighbours are parallel\r\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\r\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\r\n            else {\r\n                let triangleIntersections = [];\r\n                if(!target.point.neighboursTriangle) {\r\n                    target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\r\n                }\r\n\r\n                Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections);\r\n                \r\n                //if point of intersection of ray and tirangle are close to target point, assume ray \"glanced\" triangle.\r\n                for(let triangleIntersection of triangleIntersections) {\r\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\r\n                        castSides = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //if ray \"glanced\" mapped object cast two additional rays\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCone',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: angle,\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else\r\n                mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n        \r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection) {\r\n            //if intersection hits target point check if ray \"glanced\" mapped object.\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            \r\n            if(!castSides) {\r\n                //castSides = false;\r\n            }\r\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray and at least one line between target point and it's neighbours are parallel\r\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\r\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\r\n            else {\r\n                let triangleIntersections = [];\r\n                if(!target.point.neighboursTriangle) {\r\n                    target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\r\n                }\r\n\r\n                Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections);\r\n                \r\n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\r\n                for(let triangleIntersection of triangleIntersections) {\r\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\r\n                        castSides = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //if ray \"glanced\" mapped object cast two additional rays\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n    \r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n","/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n    \r\n    //round\r\n    if(options.round !== undefined)\r\n        this.round = (options.round == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n\r\n    //enable physics\r\n    if(options.enablePhysics !== undefined && options.enablePhysics)\r\n        this.enablePhysics(options.enablePhysics);\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\r\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        this.graphics.setDepth(1000);\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10.0\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    if(this.graphics)\r\n        this.graphics.destroy();\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\r\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\r\n *\r\n * @method Raycaster.Ray#enablePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enablePhysics(type = 'arcade') {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.collisionCircle._ray = this;\r\n\r\n    if(type === 'matter') {\r\n        this.bodyType = 'matter';\r\n\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n        else {\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body._ray = this;\r\n        this.setOnCollideActive();\r\n    }\r\n    else {\r\n        this.bodyType = 'arcade';\r\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body\r\n            .setCircle(this.collisionRange)\r\n            .setAllowGravity(false)\r\n            .setImmovable(true);\r\n        this.body._ray = this;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/*Matter physics methods for ray body*/\r\n/**\r\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique category bitfield.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionCategory(value) {\r\n    this.body.collisionFilter.category = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\r\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n * they will never collide.\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique group index.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionGroup(value) {\r\n    this.body.collisionFilter.group = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\r\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n * and `(categoryB & maskA) !== 0` are both true.*\r\n *\r\n * @method Raycaster.Ray#setCollidesWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\n\r\nexport function setCollidesWith(categories) {\r\n    var flags = 0;\r\n\r\n    if (!Array.isArray(categories))\r\n    {\r\n        flags = categories;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0; i < categories.length; i++)\r\n        {\r\n            flags |= categories[i];\r\n        }\r\n    }\r\n\r\n    this.body.collisionFilter.mask = flags;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollide\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollide(callback) {\r\n    let self = this;\r\n    this.body.onCollideCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(collisionInfo);\r\n        }\r\n    };\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideEnd\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideEnd(callback) {\r\n    this.body.onCollideEndCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            collisionInfo.rayCollided = false;\r\n            callback(collisionInfo);\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideActive\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideActive(callback) {\r\n    let self = this;\r\n    let func = function(collisionInfo) {\r\n        if(self.processOverlap(collisionInfo)) {\r\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\r\n\r\n            if(collisionInfo.rayCollided !== true) {\r\n                collisionInfo.rayCollided = true;\r\n                if(self.body.onCollideCallback) {\r\n                    self.body.onCollideCallback(collisionInfo);\r\n                }\r\n\r\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\r\n                    self.body.onCollideWith[body.id](body, collisionInfo);\r\n                }\r\n            }\r\n            if(callback)\r\n                callback(collisionInfo);\r\n        }\r\n        else {\r\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\r\n                self.body.onCollideEndCallback(collisionInfo);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.body.onCollideActiveCallback = func;\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideWith(body, callback) {\r\n    let self = this;\r\n    let func = function(body, collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(body, collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(body, collisionInfo);\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(body))\r\n    {\r\n        body = [ body ];\r\n    }\r\n\r\n    for (var i = 0; i < body.length; i++)\r\n    {\r\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n        this.body.setOnCollideWith(src, func);\r\n    }\r\n\r\n    return this;\r\n};\r\n","/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //matter physics\r\n    if(this.bodyType === 'matter') {\r\n        let isCollisionInfo = false;\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\r\n\r\n            for(let object of objects) {   \r\n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\r\n\r\n                if(this.testMatterOverlap(body))\r\n                    targets.push(body);\r\n            }\r\n        }\r\n        //get object's body\r\n        else {\r\n            if(!Array.isArray(objects))\r\n                objects = [objects];\r\n            \r\n            for(let object of objects) {\r\n                if(object === this.body)\r\n                    continue;\r\n    \r\n                if(this.testMatterOverlap(object))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n    //arcade physics\r\n    else {\r\n        let bodies = false;\r\n        //get bodies in range\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n            bodies = true;\r\n        }\r\n        //get object's body\r\n        else if(!Array.isArray(objects)) {\r\n            objects = [objects];\r\n        }\r\n        //if objects are bodies\r\n        if(bodies) {\r\n            for(let body of objects) {\r\n                if(body === this.body)\r\n                    continue;\r\n            \r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(body.gameObject);\r\n            }\r\n        }\r\n        //if objects are game objects\r\n        else {\r\n            for(let object of objects) {\r\n                if(object.body === undefined)\r\n                    continue;\r\n\r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(object.body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\r\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let obj1, obj2, target;\r\n    //check if it's matter collisionInfo object\r\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\r\n        obj1 = object1.bodyA;\r\n        obj2 = object1.bodyB;\r\n    }\r\n    else {\r\n        obj1 = object1;\r\n        obj2 = object2;\r\n    }\r\n\r\n    if(obj1._ray !== undefined && obj1._ray === this)\r\n        target = obj2;\r\n    else if(obj2._ray !== undefined && obj2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testArcadeOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testArcadeOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testMatterOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.9.0\r\n *\r\n * @param {object} body - Matter body.\r\n *\r\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testMatterOverlap(object) {\r\n    let body;\r\n\r\n    if(object.type === 'body')\r\n        body = object;\r\n    else if(object.body !== undefined)\r\n        body = object.body;\r\n    else\r\n        return false;\r\n\r\n    //if body is concave, ignore convex body\r\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\r\n    //iterate through bodies\r\n    for(let part of parts) {\r\n        let pointA = part.vertices[0];\r\n\r\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\r\n            let pointB = part.vertices[i];\r\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n\r\n            //iterate through field of view slices to check collisions with target\r\n            for(let slice of this.slicedIntersections) {\r\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\r\n\r\n                if(overlap) {\r\n                    return true;\r\n                }\r\n            }\r\n            pointA = pointB;\r\n        }\r\n\r\n        //closing segment\r\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\r\n         //iterate through field of view slices to check collisions with target\r\n        for(let slice of this.slicedIntersections) {\r\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n\r\n            if(overlap) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.collisionRange = collisionRange;\r\n    this.collisionCircle.setRadius(this.collisionRange);\r\n\r\n    if(this.bodyType === 'matter') {\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'rectangle',\r\n                    x: bounds.rectangle.centerX,\r\n                    y: bounds.rectangle.centerY,\r\n                    width: bounds.rectangle.width,\r\n                    height: bounds.rectangle.height,\r\n                    circleRadius:0\r\n                }\r\n            });\r\n        }\r\n        else if(oldRangeMax) {\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'circle',\r\n                    x: this.collisionCircle.x,\r\n                    y: this.collisionCircle.y\r\n                },\r\n                circleRadius: this.collisionRange,\r\n                isStatic: false\r\n            });\r\n        }\r\n        else {\r\n            this.collisionCircle.setRadius(this.collisionRange);\r\n        }\r\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else {\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            objectBounds = object.raycasterMap.getBoundingBox();\r\n        else\r\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\r\n    }\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {number}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray's hit points will be rounded.\r\n    *\r\n    * @name Raycaster.Ray#round\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.1\r\n    */\r\n    this.round = false;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {object}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    /**\r\n    * Physics body type.\r\n    *\r\n    * @name Raycaster.Ray#bodyType\r\n    * @type {(boolean|'arcade'|'matter')}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.bodyType = false;\r\n\r\n    /**\r\n    * Ray casting stats.\r\n    *\r\n    * @name Raycaster.Ray#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {string} method Used casting method (cast, castCircle, castCone).\r\n    * @property {number} rays Casted rays.\r\n    * @property {number} testedMappedObjects Tested mapped objects.\r\n    * @property {number} hitMappedObjects Hit mapped objects.\r\n    * @property {number} segments Tested segments.\r\n    * @property {number} time Casting time.\r\n    */\r\n    this._stats = {\r\n        method: 'cast',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    /**\r\n    * Ray's graphics object used for debug\r\n    *\r\n    * @name Raycaster.Ray#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n     this.graphics;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    getStats: require('./stats.js').getStats,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\r\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\r\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\r\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\r\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\r\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\r\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\r\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\r\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\r\n    drawDebug: require('./debug.js').drawDebug,\r\n    destroy: require('./destroy.js').destroy,\r\n};\r\n","/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} [angle] - Ray's angle in radians.\r\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\r\n    return this;\r\n}\r\n","/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.11';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.10.6\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update, this);\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update, this);\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index === -1) {\r\n                continue;\r\n            }\r\n            \r\n            this.mappedObjects.splice(index, 1);\r\n            \r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap.destroy();\r\n            }\r\n            else {\r\n                object.data.get('raycasterMap').destroy();\r\n            }\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n            \r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else if(object.data)\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n        \r\n        if(this.graphics)\r\n            this.graphics.destroy();\r\n        \r\n        if(this.scene) {\r\n            this.scene.events.removeListener('update', null, this);\r\n        }\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.js\");\n",""],"names":["PhaserRaycaster","_Phaser$Plugins$Scene","scene","pluginManager","_this","_classCallCheck","_callSuper","_Raycaster","require","Raycaster","_inherits","_createClass","key","value","createRaycaster","options","arguments","length","undefined","Phaser","Plugins","ScenePlugin","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","ray","_points","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","neighbours","_segments","scaleY","geom","segments","newPoints","_iterator","_createForOfIteratorHelper","_step","s","n","done","point","err","e","f","_iterator2","_step2","i","prevPoint","slice","nextPoint","isChild","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","_iterator3","_step3","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","childPoints","_iterator4","_step4","childPoint","previousPoint","_iterator5","_step5","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","_iterator6","_step6","childMapCircle","Map","raycaster","_raycaster","_dynamic","prototype","dynamicMappedObjects","_stats","mappedObjects","static","total","index","indexOf","splice","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","indexedPoints","part","isInternal","_i2","_parts","matter","composite","Rectangle","min","max","closePath","pop","shift","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","x1","y1","x2","y2","LineToCircle","detectionRangeCircle","columns","Array","layer","row","tileWidth","tileHeight","startPoint","endPoint","includes","tile","higherRow","isCollisionTile","isCollisionHigherTile","column","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","boundingBoxIntersections","canTestMap","_boundingBox","setTo","width","height","ContainsPoint","boundingBoxIntersection","Equals","isTangent","circleIntersections","GetLineToCircle","_iterator7","_step7","_iterator8","_step8","_iterator9","_step9","result","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","_i","_rayTargets","castSides","roundedTarget","BetweenPoints","triangleIntersections","neighboursTriangle","Triangle","GetTriangleToLine","_triangleIntersection","triangleIntersection","abs","intersectionA","intersectionB","autoSlice","slicedIntersections","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","TriangleToLine","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","version","mapPoint","mapSegment","mapBoundingBox","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","_typeof","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","enableMaps","disableMaps","mapppedObject","createRay","strokeRectShape","removeListener"],"sourceRoot":""}