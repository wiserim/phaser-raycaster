{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/raycaster-core.js"],"names":["PhaserRaycaster","scene","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","prototype","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","name","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","dynamic","active","ray","_points","length","points","offset","Phaser","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","getCircles","tempRay","_raycaster","createRay","list","child","map","data","get","iterate","setDataEnabled","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","bind","iLength","childA","mapA","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","Map","raycaster","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","find","segmentIndex","findIndex","x1","y1","x2","y2","splice","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","index","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestDistance","intersections","GetLineToRectangle","distance","target","objects","mappedObjects","raycasterMap","Equals","isTangent","circleIntersections","Circle","GetLineToCircle","result","ignoreNotIntersectedRays","round","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","setTo","angleDeg","collisionRange","enablePhysics","collisionCircle","add","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","value","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testOverlap","CircleToCircle","CircleToRectangle","testArcadeOverlap","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","setRay","closed","slices","version","graphics","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","lineStyle","color","fillStyle","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","indexOf","enableMaps","disableMaps","mapppedObject"],"mappings":"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AA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASqC,GAAT,CAAa7G,OAAb,EAAsB8G,SAAtB,EAAiC;AACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI,OAAKhC,UAAL,GAAkBgC,SAAS,GAAGA,SAAH,GAAe,KAA1C;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAK1F,IAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKY,MAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKD,OAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKP,MAAL,GAAc,KAAd;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKhB,MAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAK0B,OAAL,GAAe,EAAf;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKmC,SAAL,GAAiB,EAAjB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKhD,SAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKC,WAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKf,cAAL;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,OAAKgB,SAAL;AAEA,OAAKJ,MAAL,CAAYnB,OAAZ;AACA,OAAKuB,SAAL;AAEA,SAAO,IAAP;AACH;AAAA;AAEDsF,GAAG,CAAClI,SAAJ,GAAgB;AACZwC,QAAM,EAAEhB,mBAAO,CAAC,wCAAD,CAAP,CAAuBgB;AADnB,CAAhB;AAIA0F,GAAG,CAAClI,SAAJ,CAAcuB,WAAd,GAA4B2G,GAA5B,C;;;;;;;;;;;;ACjJA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA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","file":"phaser-raycaster.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.js\");\n","var PhaserRaycaster = function (scene)\n{\n    //The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //A test method.\n    test: function (name)\n    {\n        console.log('RaycasterPlugin says hello ' + name + '!');\n    },\n\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    //Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.updateMap = container.updateMap;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, getCircles = false) {\n    if(!this.active)\n        return [];\n\n    let points = [];\n    if(!getCircles)\n        points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(ray){\n        //create temporary ray\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n        let tempRay = ray._raycaster.createRay({\n            origin: {\n                x: vector.getPointB().x,\n                y: vector.getPointB().y\n            }\n        });\n\n        for(let child of this.object.list){\n            if(child.type === 'Arc'){\n\n                let map = child.data.get('raycasterMap');\n                if(map._points.length == 0){\n                    for(let point of map.getPoints(tempRay, true)){\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\n                    }\n                }\n            }\n            else if(child.type === 'Container') {\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\n                    if(this.object.rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n                }\n            }\n\n        }\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    //iterate through container's children\n    container.iterate(function(child){\n        if(!child.data)\n            child.setDataEnabled();\n\n        //get child map\n        let map = child.data.get('raycasterMap');\n        if(!map) {\n            map = new this.constructor({\n                object: child,\n                segmentCount: this.segmentCount\n            });\n            child.data.set('raycasterMap', map);\n        }\n        else\n            map.updateMap();\n\n        //add child points\n        let childPoints = [];\n        for(let point of map.getPoints()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                points.push(vector.getPointB());\n            }\n            //if rotation === 0\n            else\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\n\n            childPoints.push(points[points.length - 1])\n        }\n\n        //add child segments\n        for(let segment of map.getSegments()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let pointA = segment.getPointA();\n                let pointB = segment.getPointB();\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n            }\n            //if rotation === 0\n            else\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\n        }\n\n    }.bind(this));\n\n    //get children intersections\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\n        let childA = container.list[i];\n        let mapA = childA.data.get('raycasterMap');\n\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n            let childB = container.list[j];\n            let mapB = childB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                continue;\n\n            //find objects intersections\n            for(let segmentA of mapA.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                     //calculate positions after container's rotation\n                    if(rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map#dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this.dynamic;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {integer} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {float} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {float} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestDistance = this.rayRange;\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //check if object is intersected by ray\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, map.getBoundingBox()))\n            continue;\n\n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                    }\n                }\n            }\n        }\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n    \n    return result;\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n        }\n\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n            let object = options.objects[i];\n            //if bound in range\n            if(!this.boundsInRange(object))\n                continue;\n            \n            testedObjects.push(object);\n\n            let map;\n            if(object.type === 'body' || object.type === 'composite')\n                map = object.raycasterMap;\n            else\n                map = object.data.get('raycasterMap');\n\n            maps.push(map);\n            //get points and angles\n            for(let point of map.getPoints(this)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n\n            //get objects intersections\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n                let objectB = options.objects[j];\n                let mapB;\n                if(objectB.type === 'body' || objectB.type === 'composite')\n                    mapB = objectB.raycasterMap;\n                else {\n                    mapB = objectB.data.get('raycasterMap');\n                }\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                    continue;\n                \n                //find objects intersections\n                for(let segmentA of map.getSegments(this)) {\n                    for(let segmentB of mapB.getSegments(this)) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                        });\n                    }\n                }\n            }\n        }\n\n        //sort target points by angle\n        rayTargets.sort(function(a, b){\n            //if rays towards points have the same angles promote closer one\n            if(a.angle == b.angle) {\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                    return 1;\n                else\n                    return -1;\n            }\n\n            return a.angle - b.angle;\n        }.bind(this));\n\n        let previousTarget = {\n            angle: false\n        };\n\n        //cast rays\n        for(let target of rayTargets){\n            //if current target is the same as previous one skip loop\n            if(target.angle === previousTarget.angle) {\n                continue;\n            }\n\n            previousTarget = target;\n\n            this.setAngle(target.angle);\n            let intersection = this.cast({\n                objects: testedObjects,\n                target: target.point\n            });\n\n            if(intersection){\n                //if intersection hits target point cast two additional rays\n                let castSides = false;\n                if(this.round) {\n                    let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                    castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n                }\n                else {\n                    castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n                }\n                if(castSides) {\n                    this.setAngle(target.angle - 0.0001);\n                    let intersectionA = this.cast({\n                        objects: testedObjects\n                    });\n\n                    if(intersectionA) {\n                        intersections.push(intersectionA);\n                    }\n\n                    intersections.push(intersection);\n\n                    this.setAngle(target.angle + 0.0001);\n                    let intersectionB = this.cast({\n                        objects: testedObjects\n                    });\n\n                    if(intersectionB) {\n                        intersections.push(intersectionB);\n                    }\n\n                    continue;\n                }\n\n                intersections.push(intersection);\n            }\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                    rayTargets.push({\n                        point: point,\n                        angle: angle,\n                        angleOffsetDeg: -angleOffsetDeg\n                    });\n                }\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {float} [options.angle = 0] - Ray's angle in radians.\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        \n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Ray specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {float}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {float}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {integer}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(bolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    //this.collisionCircle;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\n* @copyright    2020 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n/**\n * @classdesc\n *\n * Raycaster class responsible for creating ray objects and managing mapped objects.\n * \n * @namespace Raycaster\n * @class Raycaster\n * @constructor\n * @since 6.0.0\n *\n * @param {object} [options] - Raycaster's configuration options. May include:\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\n */\nexport function Raycaster(options) {\n    /**\n    * Plugin version.\n    *\n    * @name Raycaster#version\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.version = '0.9.1';\n    /**\n    * Raycaster's scene\n    *\n    * @name Raycaster#version\n    * @type {string}\n    * @private\n    * @since 0.6.0\n    */\n    this.scene;\n    this.graphics;\n\n    /**\n    * Raycaster's bounding box.\n    *\n    * @name Raycaster#boundingBox\n    * @type {Phaser.Geom.Rectangle}\n    * @default false\n    * @private\n    * @since 0.6.0\n    */\n    this.boundingBox = false;\n    /**\n    * Array of mapped game objects.\n    *\n    * @name Raycaster#mappedObjects\n    * @type {object[]}\n    * @since 0.6.0\n    */\n    this.mappedObjects = [];\n    this.sortedPoints = [];\n    /**\n    * Number of segments of circle maps.\n    *\n    * @name Raycaster#mapSegmentCount\n    * @type {integer}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.mapSegmentCount = 0;\n\n    if(options !== undefined) {\n        if(options.boundingBox === undefined && options.scene !== undefined) {\n            if(options.scene.physics !== undefined)\n                options.boundingBox = options.scene.physics.world.bounds;\n            else if(options.scene.matter !== undefined) {\n                let walls = options.scene.matter.world.walls;\n\n                if(walls.top !== null) {\n                    options.boundingBox = new Phaser.Geom.Rectangle(\n                        walls.top.vertices[3].x,\n                        walls.top.vertices[3].y,\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\n                    );\n                }\n            }\n        }\n\n        this.setOptions(options);\n\n        if(options.autoUpdate === undefined || options.autoUpdate)\n            //automatically update event\n            this.scene.events.on('update', this.update.bind(this));\n    }\n    else\n        //automatically update event\n        this.scene.events.on('update', this.update.bind(this));\n\n    return this;\n}\n\nRaycaster.prototype = {\n    /**\n    * Configure raycaster.\n    *\n    * @method Raycaster#setOptions\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    setOptions: function(options) {\n        if(options.scene !== undefined) {\n            this.scene = options.scene;\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        }\n\n        if(options.mapSegmentCount !== undefined)\n            this.mapSegmentCount = options.mapSegmentCount;\n\n        if(options.objects !== undefined)\n            this.mapGameObjects(options.objects);\n\n        if(options.boundingBox !== undefined)\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\n\n        return this;\n    },\n\n    /**\n    * Set Raycatser's bounding box.\n    *\n    * @method Raycaster#setBoundingBox\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\n    * @param {integer} width - The width of bounding box.\n    * @param {integer} height - The height of bounding box.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    setBoundingBox: function(x, y, width, height) {\n        this.boundingBox = {\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\n            points: [],\n            segments: []\n        }\n        //set points\n        let points = [\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\n        ];\n\n        this.boundingBox.points = points;\n\n        //set segments\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\n            if(i+1 < length)\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n            else\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n        }\n    },\n\n    /**\n    * Map game objects\n    *\n    * @method Raycaster#mapGameObjects\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\n        options.dynamic = dynamic;\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\n\n        if(!Array.isArray(objects))\n            objects = [objects];\n        \n        for(let object of objects) {\n            if(this.mappedObjects.includes(object))\n                continue;\n\n            let config = {};\n            for(let option in options) {\n                config[option] = options[option];\n            }\n            config.object = object;\n            \n            let map = new this.Map(config, this);\n\n            if(object.type === 'body' || object.type === 'composite') {\n                object.raycasterMap = map;\n            }\n            else if(!object.data) {\n                object.setDataEnabled();\n                object.data.set('raycasterMap', map);\n            }\n\n            this.mappedObjects.push(object);\n        }\n        return this;\n    },\n\n    /**\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\n    *\n    * @method Raycaster#removeMappedObjects\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    removeMappedObjects: function(objects) {\n        if(!Array.isArray(objects))\n            objects = [objects];\n\n        for(let object of objects) {\n            let index = this.mappedObjects.indexOf(object);\n            if(index >= 0)\n                this.mappedObjects.splice(index, 1)\n        }\n\n        return this;\n    },\n\n    /**\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\n    *\n    * @method Raycaster#enableMaps\n    * @memberof Raycaster\n    * @instance\n    * @since 0.7.2\n    *\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    enableMaps: function(objects) {\n        if(!Array.isArray(objects))\n            objects = [objects];\n        \n        for(let object of objects) {\n            let map;\n\n            if(object.type === 'body' || object.type === 'composite') {\n                map = object.raycasterMap;\n            }\n            else if(object.data) {\n                map = object.data.get('raycasterMap');\n            }\n\n            if(map)\n                map.active = true;\n        }\n\n        return this;\n    },\n\n    /**\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\n    *\n    * @method Raycaster#disableMaps\n    * @memberof Raycaster\n    * @instance\n    * @since 0.7.2\n    *\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    disableMaps: function(objects) {\n        if(!Array.isArray(objects))\n            objects = [objects];\n        \n        for(let object of objects) {\n            let map;\n\n            if(object.type === 'body' || object.type === 'composite') {\n                map = object.raycasterMap;\n            }\n            else if(object.data) {\n                map = object.data.get('raycasterMap');\n            }\n\n            if(map)\n                map.active = false;\n        }\n\n        return this;\n    },\n\n    /**\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\n    *\n    * @method Raycaster#update\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    */\n    update: function() {\n        //update dynamic maps\n        if(this.mappedObjects.length > 0)\n            for(let mapppedObject of this.mappedObjects) {\n                let map;\n\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\n                    map = mapppedObject.raycasterMap;\n                }\n                else if(mapppedObject.data) {\n                    map = mapppedObject.data.get('raycasterMap');\n                }\n\n                if(!map)\n                    continue;\n\n                if(map.dynamic)\n                    map.updateMap();\n            }\n    },\n\n    /**\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\n    *\n    * @method Raycaster#createRay\n    * @memberof Raycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Ray options:\n    *\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n    */\n    createRay: function(options = {}) {\n        return new this.Ray(options, this);\n    }\n}\n\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\n"],"sourceRoot":""}