{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/debug.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setCollisionCategory","this","body","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","length","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","setOnCollideActive","onCollideActiveCallback","bodyA","label","bodyB","undefined","onCollideWith","id","setOnCollideWith","func","src","setRayRange","rayRange","Phaser","Math","MAX_SAFE_INTEGER","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","detectionRangeCircle","setTo","setCollisionRange","collisionRange","oldRangeMax","collisionCircle","setRadius","bodyType","bounds","_raycaster","boundingBox","scene","matter","set","shape","type","rectangle","centerX","centerY","width","height","circleRadius","isStatic","setCircle","boundsInRange","objectBounds","raycasterMap","getBoundingBox","data","Intersects","CircleToRectangle","overlap","objects","targets","overlapCircle","Circle","query","collides","getMatterBodies","testMatterOverlap","push","bodies","physics","overlapCirc","hitbox","isCircle","position","halfWidth","Rectangle","testArcadeOverlap","gameObject","CircleToCircle","object1","object2","obj1","obj2","target","slicedIntersections","slice","TriangleToCircle","RectangleToTriangle","parts","splice","part","pointA","vertices","pointB","segment","TriangleToLine","Triangle","ContainsPoint","getPointA","getPointB","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","PhaserRaycaster","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","debugOptions","enabled","maps","rays","ray","rayPoint","mapPoint","mapSegment","mapBoundingBox","_stats","mappedObjects","total","static","dynamic","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","add","lineStyle","color","fillStyle","setDepth","debug","assign","mapGameObjects","setBoundingBox","points","segments","Point","left","right","segmentCount","includes","config","option","map","Map","setDataEnabled","removeMappedObjects","index","indexOf","enableMaps","active","disableMaps","dynamicMaps","mapppedObject","updateMap","drawDebug","createRay","Ray","getStats","clear","strokeRectShape","getSegments","strokeLineShape","getPoints","point","fillPoint","raycaster","circle","_points","_segments","line","polygon","arc","container","tilemap","matterBody","setSegmentCount","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","geom","rotation","vectorA","scaleX","scaleY","Length","vectorB","vector","closePath","last","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","getCircles","tempRay","list","child","iterate","childPoints","iLength","childA","mapA","j","jLength","childB","mapB","RectangleToRectangle","getBounds","segmentA","segmentB","intersection","LineToLine","Distance","Between","x1","y1","x2","y2","LineToCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","leftEdge","vertical","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","scale","generateBounds","bodyItem","find","segmentIndex","findIndex","closingSegment","composite","min","max","count","ignoreNotIntersectedRays","round","autoSlice","intersections","method","testedMappedObjects","hitMappedObjects","setRay","cast","castCircle","castCone","enablePhysics","angleDeg","coneDeg","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","GetLineToRectangle","distance","result","_boundingBox","Equals","isTangent","circleIntersections","GetLineToCircle","originalAngle","rayTargets","testedObjects","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs","closed","slices","isSensor","ignoreGravity","existing","setAllowGravity","setImmovable"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {float} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {float} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","var PhaserRaycaster = function (scene)\n{\n    //The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //A test method.\n    test: function (name)\n    {\n        console.log('RaycasterPlugin says hello ' + name + '!');\n    },\n\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    //Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2021 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {bool|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.2';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {bool} [enable = false] Enable debug mode\r\n    * @property {bool} [maps = true] - Enable maps debug\r\n    * @param {bool} [rays = true] - Enable rays debug\r\n    * @property {bool} graphics - Debug graphics options\r\n    * @property {bool|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {bool|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {integer}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {bool|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n            \r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycatser's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {integer} width - The width of bounding box.\r\n    * @param {integer} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic++;\r\n            else\r\n                this._stats.mappedObjects.static++;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1);\r\n            \r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic--;\r\n            else\r\n                this._stats.mappedObjects.static--;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        let dynamicMaps = 0;\r\n        if(this.mappedObjects.length > 0) {\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.dynamic) {\r\n                    map.updateMap();\r\n                    dynamicMaps++;\r\n                }\r\n            }\r\n\r\n            //update stats\r\n            this._stats.mappedObjects.static = this.mappedObjects.length - dynamicMaps;\r\n            this._stats.mappedObjects.dynamic = dynamicMaps;\r\n\r\n            //debug\r\n            if(this.debugOptions.enabled)\r\n                this.drawDebug();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray options:\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n\r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map#dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this.dynamic;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config\n};\n\nMap.prototype.constructor = Map;\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, getCircles = false) {\n    if(!this.active)\n        return [];\n\n    let points = [];\n    if(!getCircles)\n        points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(ray){\n        //create temporary ray\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n        let tempRay = ray._raycaster.createRay({\n            origin: {\n                x: vector.getPointB().x,\n                y: vector.getPointB().y\n            }\n        });\n\n        for(let child of this.object.list){\n            if(child.type === 'Arc'){\n\n                let map = child.data.get('raycasterMap');\n                if(map._points.length == 0){\n                    for(let point of map.getPoints(tempRay, true)){\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\n                    }\n                }\n            }\n            else if(child.type === 'Container') {\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\n                    if(this.object.rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n                }\n            }\n\n        }\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    //iterate through container's children\n    container.iterate(function(child){\n        if(!child.data)\n            child.setDataEnabled();\n\n        //get child map\n        let map = child.data.get('raycasterMap');\n        if(!map) {\n            map = new this.constructor({\n                object: child,\n                segmentCount: this.segmentCount\n            });\n            child.data.set('raycasterMap', map);\n        }\n        else\n            map.updateMap();\n\n        //add child points\n        let childPoints = [];\n        for(let point of map.getPoints()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                points.push(vector.getPointB());\n            }\n            //if rotation === 0\n            else\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\n\n            childPoints.push(points[points.length - 1])\n        }\n\n        //add child segments\n        for(let segment of map.getSegments()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let pointA = segment.getPointA();\n                let pointB = segment.getPointB();\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n            }\n            //if rotation === 0\n            else\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\n        }\n\n    }.bind(this));\n\n    //get children intersections\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\n        let childA = container.list[i];\n        let mapA = childA.data.get('raycasterMap');\n\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n            let childB = container.list[j];\n            let mapB = childB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                continue;\n\n            //find objects intersections\n            for(let segmentA of mapA.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                     //calculate positions after container's rotation\n                    if(rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {integer} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Ray specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {float}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {float}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {integer}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(bolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug\n};\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {float} [options.angle = 0] - Ray's angle in radians.\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox).length === 0)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    rayTargets.push({\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    });\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            \n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}"],"sourceRoot":""}