{"version":3,"file":"phaser-raycaster.min.js","mappings":"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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * Point object\r\n * @typedef {Object} Point\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n \r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster plugin class.\r\n * \r\n * @namespace PhaserRaycaster\r\n * @class PhaserRaycaster\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {Phaser.Scene} scene\r\n * @param {Phaser.Plugins.PluginManager} pluginManager\r\n */\r\n\r\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\r\n    constructor(scene, pluginManager) {\r\n        super(scene, pluginManager);\r\n\r\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\r\n    }\r\n\r\n    /**\r\n    * Create Raycaster object.\r\n    *\r\n    * @method PhaserRaycaster#createRaycaster\r\n    * @memberof PhaserRaycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    createRaycaster(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n}\r\n\r\n//Make sure you export the plugin for webpack to expose\r\nmodule.exports = PhaserRaycaster;","/**\r\n* Get mapped object's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    return this.object.getBounds();\r\n}\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\nlet matterBody = require('./map-matterBody-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet boundingBox = require('./boundingBox.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\r\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\r\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    if(options.type === 'body' || options.type === 'composite')\r\n        options.type = 'MatterBody';\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.circle = (options.segmentCount) ? false : true;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            //container's child\r\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            //transformed container's circle children\r\n            this._circles = [];\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = container.updateMap;\r\n            this._updateChildMap = container._updateChildMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'TilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'MatterBody':\r\n            //force convex body (hull) mapping\r\n            this.forceConvex = (options.forceConvex) ? true : false;\r\n            //force mapping by vertices\r\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\r\n            this.circle = false;\r\n            this.getPoints = matterBody.getPoints;\r\n            this.getSegments = matterBody.getSegments;\r\n            this.getBoundingBox = matterBody.getBoundingBox;\r\n            this.updateMap = matterBody.updateMap;\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //if object is not supported\r\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\r\n        this.notSupported = true;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete this.object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //add tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n        //assign neighbours\r\n        points[0].neighbours = [points[1]];\r\n        points[1].neighbours = [points[0]];\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n    \r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n* @param {boolean} [isChild] - Flag definig if it is child container.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, isChild = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(this.segmentCount == 0 && !isChild) {\r\n        if(ray) {\r\n            //create temporary ray\r\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n\r\n            //calculate tangent rays\r\n            let rayA = new Phaser.Geom.Line(),\r\n                rayB = new Phaser.Geom.Line(),\r\n                c;\r\n\r\n            for(let circle of this._circles) {\r\n                circle.points = [];\r\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\r\n\r\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\r\n\r\n                //ray angle\r\n                let angle = Phaser.Geom.Line.Angle(c);\r\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\r\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n                //adding tangent points\r\n                circle.points.push(rayA.getPointB());\r\n                circle.points.push(rayB.getPointB());\r\n                points.push(rayA.getPointB());\r\n                points.push(rayB.getPointB());\r\n            }\r\n        }\r\n    }\r\n    \r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n    this._circles = [];\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    if(this.mapChild) {\r\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\r\n    }\r\n    else {\r\n        //iterate through container's children\r\n        container.iterate(function(child){\r\n            this._updateChildMap(child, points, segments, rotation, offset);\r\n        }.bind(this));\r\n\r\n        //get children intersections\r\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n            let childA = container.list[i];\r\n            let mapA = childA.data.get('raycasterMap');\r\n            \r\n            if(!mapA)\r\n                continue;\r\n\r\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n                let childB = container.list[j];\r\n                let mapB = childB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                    continue;\r\n\r\n                //find objects intersections\r\n                for(let segmentA of mapA.getSegments()) {\r\n                    for(let segmentB of mapB.getSegments()) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        //calculate positions after container's rotation\r\n                        if(rotation !== 0) {\r\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\r\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                            points.push(vector.getPointB());\r\n                        }\r\n                        //if rotation === 0\r\n                        else\r\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Update container's child map of points and segments.\r\n*\r\n* @method Raycaster.Map#container._updateChildMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.10.3\r\n*\r\n* @param {object} [child] - Container's child object.\r\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\r\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\r\n* @param {number} [rotation] - Container's rotation.\r\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\r\n*/\r\nexport function _updateChildMap(child, points, segments, rotation, offset) {\r\n    if(!child.data)\r\n        child.setDataEnabled();\r\n\r\n    //if object is not supported\r\n    if(child.data.get('raycasterMapNotSupported'))\r\n        return;\r\n\r\n    //get child map\r\n    let map = child.data.get('raycasterMap');\r\n    if(!map) {\r\n        map = new this.constructor({\r\n            object: child,\r\n            segmentCount: this.segmentCount\r\n        });\r\n\r\n        if(map.notSupported) {\r\n            map.destroy();\r\n            child.data.set('raycasterMapNotSupported', true);\r\n            return;\r\n        }\r\n\r\n        child.data.set('raycasterMap', map);\r\n    }\r\n    else\r\n        map.updateMap();\r\n\r\n    //add child points\r\n    let childPoints = [];\r\n    for(let point of map.getPoints(false, true)) {\r\n        let childPoint;\r\n\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            childPoint = vector.getPointB();\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            childPoint = new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y);\r\n\r\n        //add neighbour points\r\n        childPoint.neighbours = [];\r\n        if(childPoints.length > 0) {\r\n            let previousPoint = childPoints.slice(-1)[0];\r\n            previousPoint.neighbours.push(childPoint);\r\n            childPoint.neighbours.push(previousPoint);\r\n        }\r\n        \r\n        childPoints.push(childPoint);\r\n        points.push(childPoint);\r\n    }\r\n\r\n    //add neighbour point to last child point\r\n    if(childPoints.length > 0) {\r\n        childPoints.slice(-1)[0].neighbours.push(childPoints[0]);\r\n    }\r\n\r\n    //add child segments\r\n    for(let segment of map.getSegments()) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let pointA = segment.getPointA();\r\n            let pointB = segment.getPointB();\r\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\r\n    }\r\n\r\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\r\n    if(map.type == 'Arc' && this.segmentCount == 0) {\r\n        let circleOffset = new Phaser.Geom.Point();\r\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\r\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\r\n\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            circleOffset = vector.getPointB();\r\n        }\r\n\r\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\r\n    }\r\n    else if(map.type === 'Container') {\r\n        for(let childMapCircle of map._circles) {\r\n            let circleOffset = new Phaser.Geom.Point();\r\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\r\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\r\n\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                circleOffset = vector.getPointB();\r\n            }\r\n\r\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Map#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.9.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map_dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this._dynamic = false;\r\n    /**\r\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\r\n    *\r\n    * @name Raycaster.Map#circle\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.circle = false;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Get mapped object's bounding box.\r\n    *\r\n    * @method Raycaster.Map#getBoundingBox\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.9.0\r\n    *\r\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\r\n    */\r\n    this.getBoundingBox;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n\r\n    this.config(options);\r\n    if(!this.notSupported)\r\n        this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    destroy: require('./destroy.js').destroy,\r\n    get dynamic() {\r\n        return this._dynamic;\r\n    },\r\n    set dynamic(dynamic) {\r\n        if(this._dynamic == dynamic)\r\n            return this;\r\n    \r\n        if(dynamic) {\r\n            this._dynamic = true;\r\n            \r\n            //add object to raycaster's dynamic objects list\r\n            if(this._raycaster) {\r\n                this._raycaster.dynamicMappedObjects.push(this.object);\r\n    \r\n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\r\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\r\n            }\r\n        }\r\n        else {\r\n            this._dynamic = false;\r\n            \r\n            //remove object from reycasters' dynamic objects list\r\n            if(this._raycaster) {\r\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\r\n                if(index >= 0)\r\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\r\n    \r\n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\r\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\r\n            }\r\n        }\r\n    \r\n        return this;\r\n     }\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n    //assign neighbours\r\n    points[0].neighbours = [points[1]];\r\n    points[1].neighbours = [points[0]];\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for matter body*/\r\n/**\r\n* Get array of mapped matter body's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#matterBody.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n\r\n    //calculate tangent rays\r\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\r\n        let points = [];\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB(), rayB.getPointB());\r\n\r\n        return points;\r\n    }\r\n\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped matter body's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#matterBody.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update matter body's map of points and segments.\r\n*\r\n* @method Raycaster.Map#matterBody.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n    let bodies = [body];\r\n    let generateBounds = false;\r\n\r\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\r\n        this.circle = true;\r\n        this._points = points;\r\n        this._segments = segments;\r\n\r\n        return this;\r\n    }\r\n\r\n    this.circle = false;\r\n\r\n    if(body.type == 'composite')\r\n        bodies = body.bodies;\r\n\r\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\r\n        generateBounds = true;\r\n    }\r\n    \r\n    for(let bodyItem of bodies) {\r\n        //if convex body\r\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\r\n            let vertices = bodyItem.parts[0].vertices;\r\n\r\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\r\n            points[0].neighbours = [];\r\n\r\n            for(let i = 1, length = vertices.length; i < length; i++) {\r\n                let pointA = points.slice(-1)[0],\r\n                    pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\r\n                    \r\n                if(!pointA.neighbours)\r\n                    pointA.neighbours = [];\r\n                pointA.neighbours.push(pointB);\r\n                pointB.neighbours = [pointA];\r\n\r\n                points.push(pointB);\r\n\r\n                //add segment\r\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                segments.push(segment);\r\n            }\r\n\r\n            //closing segment\r\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n            segments.push(segment);\r\n\r\n            points[0].neighbours.push(points.slice(-1)[0]);\r\n        }\r\n\r\n        //if concave body\r\n        else {\r\n            let parts = [],\r\n                indexedPoints = [];\r\n\r\n            for(let i = 1, iLength = bodyItem.parts.length; i < iLength; i++) {\r\n                let vertices = bodyItem.parts[i].vertices,\r\n                    part = [];\r\n                \r\n                for(let j = 0, jLength = vertices.length; j < jLength; j++) {\r\n                    let point = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\r\n\r\n                    if(part.length) {\r\n                        let prevPoint = part.slice(-1)[0];\r\n                        point.neighbours = [prevPoint];\r\n                        prevPoint.neighbours.push(point);\r\n                    }\r\n                    else {\r\n                        point.neighbours = [];\r\n                    }\r\n\r\n                    let index = vertices[j].x + '/' + vertices[j].y;\r\n                    if(indexedPoints[index] === undefined) {\r\n                        points.push(point);\r\n                        indexedPoints[index] = point;\r\n                    }\r\n                    else {\r\n                        indexedPoints[index].neighbours.push(point);\r\n                        point.neighbours.push(indexedPoints[index]);\r\n                    }\r\n\r\n                    part.push(point);\r\n\r\n                    if(vertices[j].isInternal) {\r\n                        parts.push(part);\r\n                        part = [];\r\n                    }\r\n                }\r\n                parts.push(part);\r\n            }\r\n\r\n            for(let part of parts) {\r\n                let i = 0,\r\n                iLength;\r\n                for(i = 0, iLength = part.length - 1; i < iLength; i++) {\r\n                    segments.push(new Phaser.Geom.Line(part[i].x, part[i].y, part[i+1].x, part[i+1].y));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    if(generateBounds) {\r\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\r\n        body.bounds = bounds;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Get matter body's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\r\n\r\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\r\n}\r\n\r\n","/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is not closed\r\n    if(!this.object.closePath) {\r\n       segments.pop();\r\n       points[0].neighbours.shift();\r\n       points[points.length - 1].neighbours.pop();\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\r\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\r\n\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\r\n        \r\n        points[i].neighbours = [\r\n            prevPoint,\r\n            nextPoint\r\n        ];\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for tilemaps*/\r\n/**\r\n* Get array of mapped tilemap's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#tilemap.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._points;\r\n\r\n    let points = [];\r\n    for(let point of this._points) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\r\n            points.push(point);\r\n    }\r\n\r\n    //get intersections between tilemap's segments and ray's detection range edge\r\n    let segments = this.getSegments(ray);\r\n\r\n    for(let segment of segments) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\r\n        \r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#tilemap.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || (ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER)))\r\n        return this._segments;\r\n\r\n    let segments = [];\r\n    for(let segment of this._segments) {\r\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\r\n            segments.push(segment);\r\n        }\r\n    }\r\n\r\n    return segments;\r\n};\r\n\r\n/**\r\n* Update tilemap's map of points and segments.\r\n*\r\n* @method Raycaster.Map#tilemap.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [],\r\n        segments = [],\r\n        columns = Array(this.object.layer.data[0].length + 1);\r\n        \r\n        for(let i = 0, iLength = columns.length; i < iLength; i++) {\r\n            columns[i] = [];\r\n        }\r\n\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point(this.object.x, this.object.y);\r\n\r\n    let row = this.object.layer.data[0],\r\n        tileWidth = this.object.layer.tileWidth * this.object.scaleX,\r\n        tileHeight = this.object.layer.tileHeight * this.object.scaleY,\r\n        startPoint,\r\n        endPoint;\r\n\r\n    //set top horizontal lines\r\n    if(this.collisionTiles.includes(row[0].index)) {\r\n        startPoint = new Phaser.Geom.Point(offset.x, offset.y);\r\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, offset.y);\r\n\r\n        columns[0].push(startPoint);\r\n    }\r\n\r\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\r\n        let tile = row[i];\r\n        \r\n        if(!this.collisionTiles.includes(tile.index)) {\r\n            if(startPoint) {\r\n                startPoint.neighbours = [endPoint];\r\n                endPoint.neighbours = [startPoint];\r\n\r\n                points.push(startPoint, endPoint);\r\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                columns[i].push(endPoint);\r\n\r\n                startPoint = false;\r\n                endPoint = false;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        let x = i * tileWidth + offset.x,\r\n            y = offset.y;\r\n\r\n        if(!startPoint) {\r\n            startPoint = new Phaser.Geom.Point(x, y);\r\n            columns[i].push(startPoint);\r\n        }\r\n\r\n        if(!endPoint) {\r\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n        }\r\n        else {\r\n            endPoint.x = x + tileWidth;\r\n        }\r\n    }\r\n\r\n    if(startPoint) {\r\n        startPoint.neighbours = [endPoint];\r\n        endPoint.neighbours = [startPoint];\r\n\r\n        points.push(startPoint, endPoint);\r\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n        columns[row.length].push(endPoint);\r\n    }\r\n\r\n    startPoint = false;\r\n    endPoint = false;\r\n\r\n    for(let i = 1, iLength = this.object.layer.data.length; i < iLength; i++) {\r\n        row = this.object.layer.data[i];\r\n        let higherRow = this.object.layer.data[i - 1];\r\n\r\n        if(this.collisionTiles.includes(row[0].index) != this.collisionTiles.includes(higherRow[0].index)) {\r\n            startPoint = new Phaser.Geom.Point(offset.x,  i * tileHeight + offset.y);\r\n            endPoint = new Phaser.Geom.Point(tileWidth + offset.x, i * tileHeight + offset.y);\r\n\r\n            columns[0].push(startPoint);\r\n        }\r\n\r\n        for(let j = 1, jLength = row.length; j < jLength; j++) {\r\n            let tile = row[j],\r\n                isCollisionTile = this.collisionTiles.includes(tile.index),\r\n                isCollisionHigherTile = this.collisionTiles.includes(higherRow[j].index);\r\n            \r\n            if(isCollisionTile == isCollisionHigherTile) {\r\n                if(startPoint) {\r\n                    startPoint.neighbours = [endPoint];\r\n                    endPoint.neighbours = [startPoint];\r\n\r\n                    points.push(startPoint, endPoint);\r\n                    segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                    columns[j].push(endPoint);\r\n\r\n                    startPoint = false;\r\n                    endPoint = false;\r\n                }\r\n                continue;\r\n            }\r\n    \r\n            let x = j * tileWidth + offset.x,\r\n                y = i * tileHeight + offset.y;\r\n    \r\n            if(!startPoint) {\r\n                startPoint = new Phaser.Geom.Point(x, y);\r\n\r\n                columns[j].push(startPoint);\r\n            }\r\n    \r\n            if(!endPoint) {\r\n                endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n            }\r\n            else {\r\n                endPoint.x = x + tileWidth;\r\n            }\r\n        }\r\n    \r\n        if(startPoint) {\r\n            startPoint.neighbours = [endPoint];\r\n            endPoint.neighbours = [startPoint];\r\n\r\n            points.push(startPoint, endPoint);\r\n            segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n            columns[row.length].push(endPoint);\r\n        }\r\n\r\n        startPoint = false;\r\n        endPoint = false;\r\n    }\r\n\r\n    //set bottom horizontal lines\r\n    row = this.object.layer.data.slice(-1)[0];\r\n    let y = this.object.layer.data.length * tileHeight + offset.y;\r\n\r\n    if(this.collisionTiles.includes(row[0].index)) {\r\n        startPoint = new Phaser.Geom.Point(offset.x, y);\r\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, y);\r\n\r\n        columns[0].push(startPoint);\r\n    }\r\n\r\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\r\n        let tile = row[i];\r\n        \r\n        if(!this.collisionTiles.includes(tile.index)) {\r\n            if(startPoint) {\r\n                startPoint.neighbours = [endPoint];\r\n                endPoint.neighbours = [startPoint];\r\n\r\n                points.push(startPoint, endPoint);\r\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n                columns[i].push(endPoint);\r\n\r\n                startPoint = false;\r\n                endPoint = false;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        let x = i * tileWidth + offset.x;\r\n\r\n        if(!startPoint) {\r\n            startPoint = new Phaser.Geom.Point(x, y);\r\n\r\n            columns[i].push(startPoint);\r\n        }\r\n\r\n        if(!endPoint) {\r\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\r\n        }\r\n        else {\r\n            endPoint.x = x + tileWidth;\r\n        }\r\n    }\r\n\r\n    if(startPoint) {\r\n        startPoint.neighbours = [endPoint];\r\n        endPoint.neighbours = [startPoint];\r\n\r\n        points.push(startPoint, endPoint);\r\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\r\n\r\n        columns[row.length].push(endPoint);\r\n    }\r\n\r\n    //set vertical lines\r\n    for(let i = 0, iLength = columns.length; i < iLength; i++) {\r\n        const column = columns[i];\r\n\r\n        for(let j = 0, jLength = column.length - 1; j < jLength; j++) {\r\n            segments.push(new Phaser.Geom.Line(column[j].x, column[j].y, column[j+1].x, column[j+1].y));\r\n            column[j].neighbours.push(column[j+1]);\r\n            column[j+1].neighbours.push(column[j]);\r\n            j++;\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n\r\n/**\r\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\r\n*\r\n* @method Raycaster.Map#setCollisionTiles\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @since 0.7.3\r\n*\r\n* @param {array} [tiles = []] - Set of tile's indexes to map.\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function setCollisionTiles(tiles = []) {\r\n    this.collisionTiles = tiles;\r\n    return this;\r\n}\r\n","/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n    this.circle = count ? false : true;\r\n\r\n    this.updateMap();\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n","/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestSegment;\r\n    let closestObject;\r\n    let closestDistance = this.rayRange;\r\n    let internal = options.internal ? options.internal : false;\r\n    let startTime = performance.now();\r\n    let stats = {\r\n        method: 'cast',\r\n        rays: 1,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        let map, boundingBox, boundingBoxIntersections = [], canTestMap = false;\r\n        \r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        stats.testedMappedObjects++;\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        if(internal) {\r\n            boundingBox = map._boundingBox;\r\n        }\r\n        else {\r\n            boundingBox = map.getBoundingBox();\r\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n        }\r\n\r\n        //check if object is intersected by ray\r\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0)\r\n            continue;\r\n\r\n        //check if bounding box is closer than closest intersection\r\n        if(Phaser.Geom.Rectangle.ContainsPoint(boundingBox, this.origin)) {\r\n            canTestMap = true;\r\n        }\r\n        else {\r\n            for(let boundingBoxIntersection of boundingBoxIntersections) {\r\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) < closestDistance) {\r\n                    canTestMap = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!canTestMap)\r\n            continue;\r\n\r\n        stats.hitMappedObjects++;\r\n        stats.segments += map.getSegments(this).length;\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n                closestObject = map.object;\r\n                closestSegment = segment;\r\n            }\r\n        }\r\n\r\n        //check if map is circular\r\n        if(map.circle) {\r\n           //if circular map has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            closestObject = map.object;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                        closestObject = map.object;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //check container map's circles\r\n        if(map.type == 'Container' && map._circles.length > 0) {\r\n            for(let circle of map._circles) {\r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let isTangent = false;\r\n\r\n                    for(let point of circle.points) {\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                closestObject = map.object;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                            closestObject = map.object;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //update stats\r\n    if(internal) {\r\n        this._stats.rays++;\r\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\r\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\r\n        this._stats.segments += stats.segments;\r\n    }\r\n    else {\r\n        stats.time = performance.now() - startTime;\r\n        this._stats = stats;\r\n    }\r\n\r\n    let result;\r\n    if(!closestIntersection) {\r\n        if(this.ignoreNotIntersectedRays)\r\n            return false;\r\n\r\n        result = this._ray.getPointB();\r\n    }\r\n    else {\r\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n        result.segment = closestSegment;\r\n        result.object = closestObject;\r\n    }\r\n\r\n    if(this.round) {\r\n        result.x = Math.round(result.x);\r\n        result.y = Math.round(result.y);\r\n    }\r\n\r\n    if(!internal)\r\n        this.drawDebug([result]);\r\n    \r\n    return result;\r\n}","/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCircle',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else {\r\n                mapB = objectB.data.get('raycasterMap');\r\n            }\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                    let target = {\r\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                    };\r\n                    target.point.intersection = false;\r\n                    rayTargets.push(target);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angle - b.angle;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n\r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection) {\r\n            //if intersection hits target point check if ray \"glanced\" mapped object.\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n\r\n            if(!castSides) {\r\n                //castSides = false;\r\n            }\r\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray and at least one line between target point and it's neighbours are parallel\r\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\r\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\r\n            else {\r\n                let triangleIntersections = [];\r\n                if(!target.point.neighboursTriangle) {\r\n                    target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\r\n                }\r\n\r\n                Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections);\r\n                \r\n                //if point of intersection of ray and tirangle are close to target point, assume ray \"glanced\" triangle.\r\n                for(let triangleIntersection of triangleIntersections) {\r\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\r\n                        castSides = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //if ray \"glanced\" mapped object cast two additional rays\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCone',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: angle,\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else\r\n                mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n        \r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection) {\r\n            //if intersection hits target point check if ray \"glanced\" mapped object.\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            \r\n            if(!castSides) {\r\n                //castSides = false;\r\n            }\r\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray and at least one line between target point and it's neighbours are parallel\r\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\r\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\r\n                //castSides = true;\r\n            }\r\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\r\n            else {\r\n                let triangleIntersections = [];\r\n                if(!target.point.neighboursTriangle) {\r\n                    target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\r\n                }\r\n\r\n                Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections);\r\n                \r\n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\r\n                for(let triangleIntersection of triangleIntersections) {\r\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\r\n                        castSides = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            //if ray \"glanced\" mapped object cast two additional rays\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n    \r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n","/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n    \r\n    //round\r\n    if(options.round !== undefined)\r\n        this.round = (options.round == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n\r\n    //enable physics\r\n    if(options.enablePhysics !== undefined && options.enablePhysics)\r\n        this.enablePhysics(options.enablePhysics);\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\r\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        this.graphics.setDepth(1000);\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10.0\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    if(this.graphics)\r\n        this.graphics.destroy();\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\r\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\r\n *\r\n * @method Raycaster.Ray#enablePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enablePhysics(type = 'arcade') {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.collisionCircle._ray = this;\r\n\r\n    if(type === 'matter') {\r\n        this.bodyType = 'matter';\r\n\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n        else {\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body._ray = this;\r\n        this.setOnCollideActive();\r\n    }\r\n    else {\r\n        this.bodyType = 'arcade';\r\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body\r\n            .setCircle(this.collisionRange)\r\n            .setAllowGravity(false)\r\n            .setImmovable(true);\r\n        this.body._ray = this;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/*Matter physics methods for ray body*/\r\n/**\r\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique category bitfield.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionCategory(value) {\r\n    this.body.collisionFilter.category = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\r\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n * they will never collide.\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique group index.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionGroup(value) {\r\n    this.body.collisionFilter.group = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\r\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n * and `(categoryB & maskA) !== 0` are both true.*\r\n *\r\n * @method Raycaster.Ray#setCollidesWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\n\r\nexport function setCollidesWith(categories) {\r\n    var flags = 0;\r\n\r\n    if (!Array.isArray(categories))\r\n    {\r\n        flags = categories;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0; i < categories.length; i++)\r\n        {\r\n            flags |= categories[i];\r\n        }\r\n    }\r\n\r\n    this.body.collisionFilter.mask = flags;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollide\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollide(callback) {\r\n    let self = this;\r\n    this.body.onCollideCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(collisionInfo);\r\n        }\r\n    };\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideEnd\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideEnd(callback) {\r\n    this.body.onCollideEndCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            collisionInfo.rayCollided = false;\r\n            callback(collisionInfo);\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideActive\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideActive(callback) {\r\n    let self = this;\r\n    let func = function(collisionInfo) {\r\n        if(self.processOverlap(collisionInfo)) {\r\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\r\n\r\n            if(collisionInfo.rayCollided !== true) {\r\n                collisionInfo.rayCollided = true;\r\n                if(self.body.onCollideCallback) {\r\n                    self.body.onCollideCallback(collisionInfo);\r\n                }\r\n\r\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\r\n                    self.body.onCollideWith[body.id](body, collisionInfo);\r\n                }\r\n            }\r\n            if(callback)\r\n                callback(collisionInfo);\r\n        }\r\n        else {\r\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\r\n                self.body.onCollideEndCallback(collisionInfo);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.body.onCollideActiveCallback = func;\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideWith(body, callback) {\r\n    let self = this;\r\n    let func = function(body, collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(body, collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(body, collisionInfo);\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(body))\r\n    {\r\n        body = [ body ];\r\n    }\r\n\r\n    for (var i = 0; i < body.length; i++)\r\n    {\r\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n        this.body.setOnCollideWith(src, func);\r\n    }\r\n\r\n    return this;\r\n};\r\n","/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //matter physics\r\n    if(this.bodyType === 'matter') {\r\n        let isCollisionInfo = false;\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\r\n\r\n            for(let object of objects) {   \r\n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\r\n\r\n                if(this.testMatterOverlap(body))\r\n                    targets.push(body);\r\n            }\r\n        }\r\n        //get object's body\r\n        else {\r\n            if(!Array.isArray(objects))\r\n                objects = [objects];\r\n            \r\n            for(let object of objects) {\r\n                if(object === this.body)\r\n                    continue;\r\n    \r\n                if(this.testMatterOverlap(object))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n    //arcade physics\r\n    else {\r\n        let bodies = false;\r\n        //get bodies in range\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n            bodies = true;\r\n        }\r\n        //get object's body\r\n        else if(!Array.isArray(objects)) {\r\n            objects = [objects];\r\n        }\r\n        //if objects are bodies\r\n        if(bodies) {\r\n            for(let body of objects) {\r\n                if(body === this.body)\r\n                    continue;\r\n            \r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(body.gameObject);\r\n            }\r\n        }\r\n        //if objects are game objects\r\n        else {\r\n            for(let object of objects) {\r\n                if(object.body === undefined)\r\n                    continue;\r\n\r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(object.body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\r\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let obj1, obj2, target;\r\n    //check if it's matter collisionInfo object\r\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\r\n        obj1 = object1.bodyA;\r\n        obj2 = object1.bodyB;\r\n    }\r\n    else {\r\n        obj1 = object1;\r\n        obj2 = object2;\r\n    }\r\n\r\n    if(obj1._ray !== undefined && obj1._ray === this)\r\n        target = obj2;\r\n    else if(obj2._ray !== undefined && obj2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testArcadeOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testArcadeOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testMatterOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.9.0\r\n *\r\n * @param {object} body - Matter body.\r\n *\r\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testMatterOverlap(object) {\r\n    let body;\r\n\r\n    if(object.type === 'body')\r\n        body = object;\r\n    else if(object.body !== undefined)\r\n        body = object.body;\r\n    else\r\n        return false;\r\n\r\n    //if body is concave, ignore convex body\r\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\r\n    //iterate through bodies\r\n    for(let part of parts) {\r\n        let pointA = part.vertices[0];\r\n\r\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\r\n            let pointB = part.vertices[i];\r\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n\r\n            //iterate through field of view slices to check collisions with target\r\n            for(let slice of this.slicedIntersections) {\r\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\r\n\r\n                if(overlap) {\r\n                    return true;\r\n                }\r\n            }\r\n            pointA = pointB;\r\n        }\r\n\r\n        //closing segment\r\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\r\n         //iterate through field of view slices to check collisions with target\r\n        for(let slice of this.slicedIntersections) {\r\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n\r\n            if(overlap) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.collisionRange = collisionRange;\r\n    this.collisionCircle.setRadius(this.collisionRange);\r\n\r\n    if(this.bodyType === 'matter') {\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'rectangle',\r\n                    x: bounds.rectangle.centerX,\r\n                    y: bounds.rectangle.centerY,\r\n                    width: bounds.rectangle.width,\r\n                    height: bounds.rectangle.height,\r\n                    circleRadius:0\r\n                }\r\n            });\r\n        }\r\n        else if(oldRangeMax) {\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'circle',\r\n                    x: this.collisionCircle.x,\r\n                    y: this.collisionCircle.y\r\n                },\r\n                circleRadius: this.collisionRange,\r\n                isStatic: false\r\n            });\r\n        }\r\n        else {\r\n            this.collisionCircle.setRadius(this.collisionRange);\r\n        }\r\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else {\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            objectBounds = object.raycasterMap.getBoundingBox();\r\n        else\r\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\r\n    }\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {number}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray's hit points will be rounded.\r\n    *\r\n    * @name Raycaster.Ray#round\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.1\r\n    */\r\n    this.round = false;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {object}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    /**\r\n    * Physics body type.\r\n    *\r\n    * @name Raycaster.Ray#bodyType\r\n    * @type {(boolean|'arcade'|'matter')}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.bodyType = false;\r\n\r\n    /**\r\n    * Ray casting stats.\r\n    *\r\n    * @name Raycaster.Ray#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {string} method Used casting method (cast, castCircle, castCone).\r\n    * @property {number} rays Casted rays.\r\n    * @property {number} testedMappedObjects Tested mapped objects.\r\n    * @property {number} hitMappedObjects Hit mapped objects.\r\n    * @property {number} segments Tested segments.\r\n    * @property {number} time Casting time.\r\n    */\r\n    this._stats = {\r\n        method: 'cast',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    /**\r\n    * Ray's graphics object used for debug\r\n    *\r\n    * @name Raycaster.Ray#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n     this.graphics;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    getStats: require('./stats.js').getStats,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\r\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\r\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\r\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\r\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\r\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\r\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\r\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\r\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\r\n    drawDebug: require('./debug.js').drawDebug,\r\n    destroy: require('./destroy.js').destroy,\r\n};\r\n","/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} [angle] - Ray's angle in radians.\r\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\r\n    return this;\r\n}\r\n","/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.11';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.10.6\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update, this);\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update, this);\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index === -1) {\r\n                continue;\r\n            }\r\n            \r\n            this.mappedObjects.splice(index, 1);\r\n            \r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap.destroy();\r\n            }\r\n            else {\r\n                object.data.get('raycasterMap').destroy();\r\n            }\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n            \r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else if(object.data)\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n        \r\n        if(this.graphics)\r\n            this.graphics.destroy();\r\n        \r\n        if(this.scene) {\r\n            this.scene.events.removeListener('update', null, this);\r\n        }\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(781);\n"],"names":["root","factory","exports","module","define","amd","self","PhaserRaycaster","scene","pluginManager","_this","_classCallCheck","_callSuper","_Raycaster","require","_inherits","Phaser","Plugins","ScenePlugin","key","value","options","arguments","length","undefined","this","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","ray","_points","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","c","rayA","Line","rayB","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","neighbours","_segments","scaleY","geom","segments","_step","newPoints","_iterator","_createForOfIteratorHelper","s","n","done","point","err","e","f","_step2","_iterator2","i","prevPoint","slice","nextPoint","isChild","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","_step3","segmentA","_iterator3","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","_step4","childPoints","_iterator4","childPoint","previousPoint","_step5","_iterator5","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","_step6","_iterator6","childMapCircle","Map","raycaster","_raycaster","_dynamic","prototype","dynamicMappedObjects","_stats","mappedObjects","static","total","index","indexOf","splice","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","indexedPoints","part","isInternal","_i2","_parts","matter","composite","Rectangle","min","max","closePath","pop","shift","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","x1","y1","x2","y2","LineToCircle","detectionRangeCircle","columns","Array","layer","startPoint","endPoint","row","tileWidth","tileHeight","includes","tile","higherRow","column","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","result","boundingBoxIntersections","canTestMap","_boundingBox","setTo","width","height","ContainsPoint","boundingBoxIntersection","Equals","isTangent","circleIntersections","GetLineToCircle","_step7","_iterator7","_step8","_iterator8","_step9","_iterator9","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","_i","_rayTargets","castSides","roundedTarget","BetweenPoints","triangleIntersections","neighboursTriangle","Triangle","GetTriangleToLine","_triangleIntersection","triangleIntersection","abs","intersectionA","intersectionB","autoSlice","slicedIntersections","castCone","minAngle","maxAngle","cone","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","isArray","mask","setOnCollide","callback","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","onCollideActiveCallback","bodyA","bodyB","onCollideWith","id","setOnCollideWith","func","src","hasOwnProperty","overlap","targets","overlapCircle","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","TriangleToLine","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","Raycaster","version","mapPoint","mapSegment","mapBoundingBox","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","_typeof","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","enableMaps","disableMaps","mapppedObject","createRay","strokeRectShape","removeListener","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","prop","call","r","Symbol","toStringTag"],"sourceRoot":""}