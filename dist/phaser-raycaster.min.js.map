{"version":3,"sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setRayRange","rayRange","Phaser","Math","MAX_SAFE_INTEGER","this","Geom","Line","SetToAngle","_ray","origin","x","y","angle","setDetectionRange","detectionRange","detectionRangeCircle","setTo","setCollisionRange","collisionRange","oldRangeMax","collisionCircle","setRadius","bodyType","bounds","_raycaster","boundingBox","scene","matter","body","set","shape","type","rectangle","centerX","centerY","width","height","circleRadius","isStatic","setCircle","boundsInRange","objectBounds","raycasterMap","getBoundingBox","data","Intersects","CircleToRectangle","overlap","objects","targets","overlapCircle","Circle","undefined","query","collides","getMatterBodies","bodyA","bodyB","testMatterOverlap","push","Array","isArray","bodies","physics","overlapCirc","hitbox","isCircle","position","halfWidth","Rectangle","testOverlap","gameObject","CircleToCircle","testArcadeOverlap","processOverlap","object1","object2","target","length","slicedIntersections","slice","TriangleToCircle","RectangleToTriangle","parts","splice","part","pointA","vertices","pointB","segment","TriangleToLine","Triangle","ContainsPoint","getPointA","getPointB","setAngle","Angle","Normalize","setAngleDeg","DegToRad","setCone","cone","setConeDeg","PhaserRaycaster","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","console","log","time","delta","createRaycaster","options","_Raycaster","constructor","require","Raycaster","version","graphics","mappedObjects","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","add","lineStyle","color","fillStyle","mapGameObjects","setBoundingBox","points","segments","Point","left","right","dynamic","segmentCount","includes","config","option","map","Map","setDataEnabled","removeMappedObjects","index","indexOf","enableMaps","active","disableMaps","mapppedObject","updateMap","createRay","Ray","raycaster","circle","_points","_segments","getPoints","getSegments","line","polygon","arc","container","tilemap","matterBody","setSegmentCount","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","getTopLeft","getTopRight","getBottomRight","getBottomLeft","offset","displayWidth","originX","displayHeight","originY","geom","rotation","vectorA","scaleX","scaleY","Length","vectorB","point","vector","closePath","last","ray","rayA","rayB","cB","rayLength","sqrt","pow","radius","dAngle","asin","newPoints","getCircles","tempRay","list","child","iterate","childPoints","iLength","childA","mapA","j","jLength","childB","mapB","RectangleToRectangle","getBounds","segmentA","segmentB","intersection","LineToLine","Distance","Between","x1","y1","x2","y2","LineToCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","leftEdge","vertical","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","scale","generateBounds","bodyItem","find","segmentIndex","findIndex","closingSegment","composite","min","max","count","ignoreNotIntersectedRays","round","autoSlice","intersections","setRay","cast","castCircle","castCone","enablePhysics","angleDeg","coneDeg","closestIntersection","closestDistance","GetLineToRectangle","distance","result","Equals","isTangent","circleIntersections","GetLineToCircle","originalAngle","maps","rayTargets","testedObjects","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","minAngle","maxAngle","angleOffsetDeg","RadToDeg","ShortestBetween","abs","closed","slices","label","isSensor","ignoreGravity","existing","setAllowGravity","setImmovable"],"mappings":"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","file":"phaser-raycaster.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        object2 = object1.bodyB;\n        object1 = object1.bodyA;\n    }\n\n    if(object1._ray !== undefined && object1._ray === this)\n        target = object2;\n    else if(object2._ray !== undefined && object2._ray === this)\n        target = object1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let overlap = false;\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {float} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {float} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","var PhaserRaycaster = function (scene)\n{\n    //The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //A test method.\n    test: function (name)\n    {\n        console.log('RaycasterPlugin says hello ' + name + '!');\n    },\n\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    //Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2020 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.9.0';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    this.graphics;\r\n\r\n    /**\r\n    * Raycaster's bounding box.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {integer}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycatser's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {integer} width - The width of bounding box.\r\n    * @param {integer} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1)\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.mappedObjects.length > 0)\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.dynamic)\r\n                    map.updateMap();\r\n            }\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray options:\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Map#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.9.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map#dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this.dynamic;\r\n    /**\r\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\r\n    *\r\n    * @name Raycaster.Map#circle\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.circle = false;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Get mapped object's bounding box.\r\n    *\r\n    * @method Raycaster.Map#getBoundingBox\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.9.0\r\n    *\r\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\r\n    */\r\n    this.getBoundingBox;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n\r\n    this.config(options);\r\n    this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\nlet matterBody = require('./map-matterBody-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet boundingBox = require('./boundingBox.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\r\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    if(options.type === 'body' || options.type === 'composite')\r\n        options.type = 'MatterBody';\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.circle = (options.segmentCount) ? false : true;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.updateMap = container.updateMap;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'MatterBody':\r\n            //force convex body (hull) mapping\r\n            this.forceConvex = (options.forceConvex) ? true : false;\r\n            //force mapping by vertices\r\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\r\n            this.circle = false;\r\n            this.getPoints = matterBody.getPoints;\r\n            this.getSegments = matterBody.getSegments;\r\n            this.getBoundingBox = matterBody.getBoundingBox;\r\n            this.updateMap = matterBody.updateMap;\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, getCircles = false) {\n    if(!this.active)\n        return [];\n\n    let points = [];\n    if(!getCircles)\n        points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(ray){\n        //create temporary ray\n        let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n        let tempRay = ray._raycaster.createRay({\n            origin: {\n                x: vector.getPointB().x,\n                y: vector.getPointB().y\n            }\n        });\n\n        for(let child of this.object.list){\n            if(child.type === 'Arc'){\n\n                let map = child.data.get('raycasterMap');\n                if(map._points.length == 0){\n                    for(let point of map.getPoints(tempRay, true)){\n                        let vector = new Phaser.Geom.Line(0, 0, point.x, point.y);\n                        Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n\n                        points.push(new Phaser.Geom.Point(vector.getPointB().x + offset.x, vector.getPointB().y + offset.y));\n                    }\n                }\n            }\n            else if(child.type === 'Container') {\n                for(let point of child.data.get('raycasterMap').getPoints(tempRay, true)){\n                    if(this.object.rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + this.object.rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n                }\n            }\n\n        }\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    //iterate through container's children\n    container.iterate(function(child){\n        if(!child.data)\n            child.setDataEnabled();\n\n        //get child map\n        let map = child.data.get('raycasterMap');\n        if(!map) {\n            map = new this.constructor({\n                object: child,\n                segmentCount: this.segmentCount\n            });\n            child.data.set('raycasterMap', map);\n        }\n        else\n            map.updateMap();\n\n        //add child points\n        let childPoints = [];\n        for(let point of map.getPoints()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                points.push(vector.getPointB());\n            }\n            //if rotation === 0\n            else\n                points.push(new Phaser.Geom.Point(point.x * container.scaleX + offset.x, point.y * container.scaleX + offset.y));\n\n            childPoints.push(points[points.length - 1])\n        }\n\n        //add child segments\n        for(let segment of map.getSegments()) {\n            //calculate positions after container's rotation\n            if(rotation !== 0) {\n                let pointA = segment.getPointA();\n                let pointB = segment.getPointB();\n                let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n                let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n                Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n                Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n                segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n            }\n            //if rotation === 0\n            else\n                segments.push(new Phaser.Geom.Line(segment.getPointA().x * container.scaleX + offset.x, segment.getPointA().y * container.scaleY + offset.y, segment.getPointB().x * container.scaleX + offset.x, segment.getPointB().y * container.scaleY + offset.y));\n        }\n\n    }.bind(this));\n\n    //get children intersections\n    for(let i = 0, iLength = container.list.length; i < iLength; i++){\n        let childA = container.list[i];\n        let mapA = childA.data.get('raycasterMap');\n\n        for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n            let childB = container.list[j];\n            let mapB = childB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                continue;\n\n            //find objects intersections\n            for(let segmentA of mapA.getSegments()) {\n                for(let segmentB of mapB.getSegments()) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                     //calculate positions after container's rotation\n                    if(rotation !== 0) {\n                        let vector = new Phaser.Geom.Line(this.object.x, this.object.y, intersection.x * this.object.scaleX + offset.x, intersection.y * this.object.scaleY + offset.y);\n                        Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                        points.push(vector.getPointB());\n                    }\n                    //if rotation === 0\n                    else\n                        points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/*Map methods for matter body*/\r\n/**\r\n* Get array of mapped matter body's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#matterBody.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n\r\n    //calculate tangent rays\r\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\r\n        let points = [];\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n\r\n        return points;\r\n    }\r\n\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped matter body's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#matterBody.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update matter body's map of points and segments.\r\n*\r\n* @method Raycaster.Map#matterBody.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n    let bodies = [body];\r\n    let generateBounds = false;\r\n\r\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\r\n        this.circle = true;\r\n        this._points = points;\r\n        this._segments = segments;\r\n\r\n        return this;\r\n    }\r\n\r\n    this.circle = false;\r\n\r\n    if(body.type == 'composite')\r\n        bodies = body.bodies;\r\n\r\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\r\n        generateBounds = true;\r\n    }\r\n    \r\n    for(let bodyItem of bodies) {\r\n        //if convex body\r\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\r\n            let vertices = bodyItem.parts[0].vertices;\r\n\r\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\r\n\r\n            for(let i = 1, length = vertices.length; i < length; i++) {\r\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\r\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\r\n\r\n                points.push(pointB);\r\n\r\n                //add segment\r\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                segments.push(segment);\r\n            }\r\n\r\n            //closing segment\r\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n            segments.push(segment);\r\n        }\r\n\r\n        //if concave body\r\n        else if(bodyItem.parts.length > 1) {\r\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\r\n                let vertices = bodyItem.parts[i].vertices;\r\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\r\n\r\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\r\n                    points.push(pointA);\r\n\r\n                for(let j = 1, length = vertices.length; j < length; j++) {\r\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\r\n                    //check if segment was already added\r\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\r\n                    \r\n                    if(segmentIndex !== -1) {\r\n                        segments.splice(segmentIndex, 1);\r\n                        pointA = pointB;\r\n                        continue;\r\n                    }\r\n                    \r\n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\r\n                        points.push(pointB);\r\n\r\n                    //add segment\r\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                    segments.push(segment);\r\n                    \r\n                    pointA = pointB;\r\n                }\r\n                \r\n                //closing segment\r\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n\r\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\r\n                if(segmentIndex === undefined)\r\n                    segments.push(closingSegment);\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    if(generateBounds) {\r\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\r\n        body.bounds = bounds;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Get matter body's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\r\n\r\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\r\n}\r\n\r\n","/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {integer} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n    this.circle = count ? false : true;\r\n\r\n    this.updateMap();\r\n    return this;\r\n}\r\n","/**\r\n* Get mapped object's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    return this.object.getBounds();\r\n}\r\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Ray specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {float}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {float}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {integer}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(bolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    //this.collisionCircle;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap\n};\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {float} [options.angle = 0] - Ray's angle in radians.\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestDistance = this.rayRange;\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //check if object is intersected by ray\n        if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, map.getBoundingBox()))\n            continue;\n\n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                    }\n                }\n            }\n        }\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n    \n    return result;\n}\n","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n        }\n\n        for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n            let object = options.objects[i];\n            //if bound in range\n            if(!this.boundsInRange(object))\n                continue;\n            \n            testedObjects.push(object);\n\n            let map;\n            if(object.type === 'body' || object.type === 'composite')\n                map = object.raycasterMap;\n            else\n                map = object.data.get('raycasterMap');\n\n            maps.push(map);\n            //get points and angles\n            for(let point of map.getPoints(this)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n                });\n            }\n\n            //get objects intersections\n            for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n                let objectB = options.objects[j];\n                let mapB;\n                if(objectB.type === 'body' || objectB.type === 'composite')\n                    mapB = objectB.raycasterMap;\n                else {\n                    mapB = objectB.data.get('raycasterMap');\n                }\n                //check if bounding boxes overlap\n                if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                    continue;\n                \n                //find objects intersections\n                for(let segmentA of map.getSegments(this)) {\n                    for(let segmentB of mapB.getSegments(this)) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                        });\n                    }\n                }\n            }\n        }\n\n        //sort target points by angle\n        rayTargets.sort(function(a, b){\n            //if rays towards points have the same angles promote closer one\n            if(a.angle == b.angle) {\n                if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                    return 1;\n                else\n                    return -1;\n            }\n\n            return a.angle - b.angle;\n        }.bind(this));\n\n        let previousTarget = {\n            angle: false\n        };\n\n        //cast rays\n        for(let target of rayTargets){\n            //if current target is the same as previous one skip loop\n            if(target.angle === previousTarget.angle) {\n                continue;\n            }\n\n            previousTarget = target;\n\n            this.setAngle(target.angle);\n            let intersection = this.cast({\n                objects: testedObjects,\n                target: target.point\n            });\n\n            if(intersection){\n                //if intersection hits target point cast two additional rays\n                let castSides = false;\n                if(this.round) {\n                    let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                    castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n                }\n                else {\n                    castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n                }\n                if(castSides) {\n                    this.setAngle(target.angle - 0.0001);\n                    let intersectionA = this.cast({\n                        objects: testedObjects\n                    });\n\n                    if(intersectionA) {\n                        intersections.push(intersectionA);\n                    }\n\n                    intersections.push(intersection);\n\n                    this.setAngle(target.angle + 0.0001);\n                    let intersectionB = this.cast({\n                        objects: testedObjects\n                    });\n\n                    if(intersectionB) {\n                        intersections.push(intersectionB);\n                    }\n\n                    continue;\n                }\n\n                intersections.push(intersection);\n            }\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n\n        //if bounding box is defined add bounding box points to \n        if(this._raycaster && this._raycaster.boundingBox) {\n            for(let point of this._raycaster.boundingBox.points) {\n\n                let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n                let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                    rayTargets.push({\n                        point: point,\n                        angle: angle,\n                        angleOffsetDeg: -angleOffsetDeg\n                    });\n                }\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n\n    return intersections;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n"],"sourceRoot":""}
