<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"raycaster-core.js.html":{"id":"raycaster-core.js.html","title":"Source: raycaster-core.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: raycaster-core.js /** * @author Marcin Walczak &lt;contact@marcin-walczak.pl&gt; * @copyright 2020 Marcin Walczak * @license {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License} */ /** * @classdesc * * Raycaster class responsible for creating ray objects and managing mapped objects. * * @namespace Raycaster * @class Raycaster * @constructor * @since 6.0.0 * * @param {object} [options] - Raycaster's configuration options. May include: * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used. * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste * @param {(object|object[])} [options.objects] - Game object or array of game objects to map. * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event. */ export function Raycaster(options) { /** * Plugin version. * * @name Raycaster#version * @type {string} * @readonly * @since 0.6.0 */ this.version = '0.9.0'; /** * Raycaster's scene * * @name Raycaster#version * @type {string} * @private * @since 0.6.0 */ this.scene; this.graphics; /** * Raycaster's bounding box. * * @name Raycaster#boundingBox * @type {Phaser.Geom.Rectangle} * @default false * @private * @since 0.6.0 */ this.boundingBox = false; /** * Array of mapped game objects. * * @name Raycaster#mappedObjects * @type {object[]} * @since 0.6.0 */ this.mappedObjects = []; this.sortedPoints = []; /** * Number of segments of circle maps. * * @name Raycaster#mapSegmentCount * @type {integer} * @default 0 * @since 0.6.0 */ this.mapSegmentCount = 0; if(options !== undefined) { if(options.boundingBox === undefined &amp;&amp; options.scene !== undefined) { if(options.scene.physics !== undefined) options.boundingBox = options.scene.physics.world.bounds; else if(options.scene.matter !== undefined) { let walls = options.scene.matter.world.walls; if(walls.top !== null) { options.boundingBox = new Phaser.Geom.Rectangle( walls.top.vertices[3].x, walls.top.vertices[3].y, walls.bottom.vertices[1].x - walls.top.vertices[3].x, walls.bottom.vertices[1].y - walls.top.vertices[3].y ); } } } this.setOptions(options); if(options.autoUpdate === undefined || options.autoUpdate) //automatically update event this.scene.events.on('update', this.update.bind(this)); } else //automatically update event this.scene.events.on('update', this.update.bind(this)); return this; } Raycaster.prototype = { /** * Configure raycaster. * * @method Raycaster#setOptions * @memberof Raycaster * @instance * @since 0.6.0 * * @param {object} [options] - Raycaster's congfiguration options. May include: * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used. * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. * @param {(object|object[])} [options.objects] - Game object or array of game objects to map. * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ setOptions: function(options) { if(options.scene !== undefined) { this.scene = options.scene; this.graphics = this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } }); } if(options.mapSegmentCount !== undefined) this.mapSegmentCount = options.mapSegmentCount; if(options.objects !== undefined) this.mapGameObjects(options.objects); if(options.boundingBox !== undefined) this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height) return this; }, /** * Set Raycatser's bounding box. * * @method Raycaster#setBoundingBox * @memberof Raycaster * @instance * @since 0.6.0 * * @param {integer} x - The X coordinate of the top left corner of bounding box. * @param {integer} y - The Y coordinate of the top left corner of bounding box. * @param {integer} width - The width of bounding box. * @param {integer} height - The height of bounding box. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ setBoundingBox: function(x, y, width, height) { this.boundingBox = { rectangle: new Phaser.Geom.Rectangle(x, y, width, height), points: [], segments: [] } //set points let points = [ new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom), new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom) ]; this.boundingBox.points = points; //set segments for(let i = 0, length = this.boundingBox.points.length; i &lt; length; i++) { if(i+1 &lt; length) this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y)); else this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y)); } }, /** * Map game objects * * @method Raycaster#mapGameObjects * @memberof Raycaster * @instance * @since 0.6.0 * * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map. * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically). * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map} * * @return {Raycaster} {@link Raycaster Raycaster} instance */ mapGameObjects: function(objects, dynamic = false, options = {}) { options.dynamic = dynamic; options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount; if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { if(this.mappedObjects.includes(object)) continue; let config = {}; for(let option in options) { config[option] = options[option]; } config.object = object; let map = new this.Map(config, this); if(object.type === 'body' || object.type === 'composite') { object.raycasterMap = map; } else if(!object.data) { object.setDataEnabled(); object.data.set('raycasterMap', map); } this.mappedObjects.push(object); } return this; }, /** * Remove game object's {@link Raycaster.Map Raycaster.Map} maps. * * @method Raycaster#removeMappedObjects * @memberof Raycaster * @instance * @since 0.6.0 * * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ removeMappedObjects: function(objects) { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { let index = this.mappedObjects.indexOf(object); if(index &gt;= 0) this.mappedObjects.splice(index, 1) } return this; }, /** * Enable game object's {@link Raycaster.Map Raycaster.Map} maps. * * @method Raycaster#enableMaps * @memberof Raycaster * @instance * @since 0.7.2 * * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ enableMaps: function(objects) { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { let map; if(object.type === 'body' || object.type === 'composite') { map = object.raycasterMap; } else if(object.data) { map = object.data.get('raycasterMap'); } if(map) map.active = true; } return this; }, /** * Disable game object's {@link Raycaster.Map Raycaster.Map} maps. * * @method Raycaster#disableMaps * @memberof Raycaster * @instance * @since 0.7.2 * * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ disableMaps: function(objects) { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { let map; if(object.type === 'body' || object.type === 'composite') { map = object.raycasterMap; } else if(object.data) { map = object.data.get('raycasterMap'); } if(map) map.active = false; } return this; }, /** * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event. * * @method Raycaster#update * @memberof Raycaster * @instance * @since 0.6.0 * */ update: function() { //update dynamic maps if(this.mappedObjects.length &gt; 0) for(let mapppedObject of this.mappedObjects) { let map; if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') { map = mapppedObject.raycasterMap; } else if(mapppedObject.data) { map = mapppedObject.data.get('raycasterMap'); } if(!map) continue; if(map.dynamic) map.updateMap(); } }, /** * Create {@link Raycaster.Ray Raycaster.Ray} object. * * @method Raycaster#createRay * @memberof Raycaster * @instance * @since 0.6.0 * * @param {object} [options] - Ray options: * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ createRay: function(options = {}) { return new this.Ray(options, this); } } Raycaster.prototype.Map = require('./map/map-core.js').Map; Raycaster.prototype.Ray = require('./ray/ray-core.js').Ray; Ã— Search results Close Phaser-raycaster "},"ray_ray-core.js.html":{"id":"ray_ray-core.js.html","title":"Source: ray/ray-core.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/ray-core.js /** * @classdesc * * Ray class responsible for casting ray's and testing their collisions with mapped objects. * * @namespace Raycaster.Ray * @class Raycaster.Ray * @constructor * @since 6.0.0 * * @param {object} options - Ray specific configuration settings. * @param {Raycaster} [raycaster] - Parent raycaster object. */ export function Ray(options, raycaster) { /** * Reference to parent Raycaster object. * * @name Raycaster.Ray#_raycaster * @type {Raycaster} * @private * @since 0.6.0 */ this._raycaster = raycaster ? raycaster : false; /** * Ray's source position. * * @name Raycaster.Ray#origin * @type {Phaser.Geom.Point} * @since 0.6.0 */ this.origin = new Phaser.Geom.Point(); /** * Ray's representation used to calculating intersections. * * @name Raycaster.Ray#_ray * @type {Phaser.Geom.Line} * @private * @since 0.6.0 */ this._ray = new Phaser.Geom.Line(); /** * Ray's angle in radians. * * @name Raycaster.Ray#angle * @type {float} * @default 0 * @since 0.6.0 */ this.angle = 0; /** * Ray's cone width angle in radians. * * @name Raycaster.Ray#cone * @type {float} * @default 0 * @since 0.7.0 */ this.cone = 0; /** * Ray's maximum range * * @name Raycaster.Ray#rayRange * @type {integer} * @default Phaser.Math.MAX_SAFE_INTEGER * @since 0.6.0 */ this.rayRange = Phaser.Math.MAX_SAFE_INTEGER; /** * Ray's maximum detection range. Objects outside detection range won't be tested. * Ray tests all objects when set to 0. * * @name Raycaster.Ray#detectionRange * @type {integer} * @default * @since 0.6.0 */ this.detectionRange = 0; /** * Ray's representation of detection range used in calculating if objects are in range. * * @name Raycaster.Ray#detectionRangeCircle * @type {Phaser.Geom.Circle} * @private * @since 0.6.0 */ this.detectionRangeCircle = new Phaser.Geom.Circle(); /** * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}. * * @name Raycaster.Ray#collisionRange * @type {integer} * @default Phaser.Math.MAX_SAFE_INTEGER * @since 0.8.0 */ this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER; /** * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. * * @name Raycaster.Ray#ignoreNotIntersectedRays * @type {boolean} * @default true * @since 0.6.0 */ this.ignoreNotIntersectedRays = true; /** * If set true, ray's hit points will be rounded. * * @name Raycaster.Ray#round * @type {boolean} * @default false * @since 0.8.1 */ this.round = false; /** * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}. * * @name Raycaster.Ray#autoSlice * @type {boolean} * @default false * @since 0.8.0 */ this.autoSlice = false; /** * Array of intersections from last raycast representing field of view. * * @name Raycaster.Ray#intersections * @type {object[]} * @default [] * @since 0.8.0 */ this.intersections = []; /** * Array of triangles representing slices of field of view from last raycast. * * @name Raycaster.Ray#slicedIntersections * @type {Phaser.Geom.Triangle[]} * @default [] * @since 0.8.0 */ this.slicedIntersections = []; /** * Physics body for testing field of view collisions. * * @name Raycaster.Ray#body * @type {object} * @default undefined * @since 0.8.0 */ //this.body = false; /** * Physics body type. * * @name Raycaster.Ray#bodyType * @type {(bolean|'arcade'|'matter')} * @default false * @since 0.9.0 */ this.bodyType = false; //this.collisionCircle; this.config(options); }; Ray.prototype = { config: require('./config.js').config, setRay: require('./ray.js').setRay, setOrigin: require('./origin.js').setOrigin, setRayRange: require('./range.js').setRayRange, setAngle: require('./angle.js').setAngle, setAngleDeg: require('./angle.js').setAngleDeg, setCone: require('./cone.js').setCone, setConeDeg: require('./cone.js').setConeDeg, setDetectionRange: require('./range.js').setDetectionRange, boundsInRange: require('./range.js').boundsInRange, cast: require('./cast.js').cast, castCircle: require('./castCircle.js').castCircle, castCone: require('./castCone.js').castCone, slice: require('./slice.js').slice, setCollisionRange: require('./range.js').setCollisionRange, enablePhysics: require('./enablePhysics.js').enablePhysics, overlap: require('./overlap.js').overlap, processOverlap: require('./overlap.js').processOverlap, testArcadeOverlap: require('./overlap.js').testArcadeOverlap, testMatterOverlap: require('./overlap.js').testMatterOverlap }; Ã— Search results Close Phaser-raycaster "},"ray_config.js.html":{"id":"ray_config.js.html","title":"Source: ray/config.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/config.js /** * Configure ray. * * @method Raycaster.Ray#config * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} [options] - Ray's congfiguration options. May include: * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position. * @param {float} [options.angle = 0] - Ray's angle in radians. * @param {float} [options.angleDeg = 0] - Ray's angle in degrees. * @param {float} [options.cone = 0] - Ray's cone angle in radians. * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees. * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view. * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes. * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}. * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded. * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function config(options) { this.object = options.object; //origin if(options.origin !== undefined) this.origin.setTo(options.origin.x, options.origin.y); //angle if(options.angle !== undefined) this.angle = Phaser.Math.Angle.Normalize(options.angle); //angle deg if(options.angleDeg !== undefined) this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg)); //cone angle if(options.cone !== undefined) this.cone = options.cone; //cone angle deg if(options.coneDeg !== undefined) this.cone = Phaser.Math.DegToRad(options.coneDeg); //ray range (0 = max) if(options.rayRange !== undefined) this.rayRange = options.rayRange; //collision range (0 = max) if(options.collisionRange !== undefined) this.collisionRange = options.collisionRange; //detection range (0 = max) if(options.detectionRange !== undefined) this.detectionRange = options.detectionRange; //ignore not intersected rays if(options.ignoreNotIntersectedRays !== undefined) this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true) //round if(options.round !== undefined) this.round = (options.round == true) //auto slice if(options.autoSlice !== undefined) this.autoSlice = (options.autoSlice == true) //enable physics if(options.enablePhysics !== undefined &amp;&amp; options.enablePhysics) this.enablePhysics(options.enablePhysics); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange); return this; } Ã— Search results Close Phaser-raycaster "},"ray_cast.js.html":{"id":"ray_cast.js.html","title":"Source: ray/cast.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/cast.js /** * Cast ray to find closest intersection with tested mapped objects. * * @method Raycaster.Ray#cast * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} [options] - options that may include: * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects. * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point. * * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. */ export function cast(options = {}) { let closestIntersection; let closestDistance = this.rayRange; //if bounding box is defined check bounding box intersection if(this._raycaster &amp;&amp; this._raycaster.boundingBox) { let intersections = []; Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections); if(intersections.length === 1) closestIntersection = intersections[0]; else if(intersections.length &gt; 1) { for(let intersection of intersections) { let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; } } } //if ray target is declared else if(options.target){ let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y); //if target is within ray range if(this.rayRange &gt; distance) { closestDistance = distance; closestIntersection = options.target; } } } //if no objects to cast ray were passed, use raycasters mapped objects if(!options.objects) { if(this._raycaster) options.objects = this._raycaster.mappedObjects; else return intersections; } for(let object of options.objects) { let map; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else map = object.data.get('raycasterMap'); //check if object is intersected by ray if(!Phaser.Geom.Intersects.GetLineToRectangle(this._ray, map.getBoundingBox())) continue; //check intersections for(let segment of map.getSegments(this)) { let intersection = []; //if target point is segmemt point if(options.target) { if( Phaser.Geom.Point.Equals(options.target, segment.getPointA()) || Phaser.Geom.Point.Equals(options.target, segment.getPointB()) ) { intersection = options.target; } else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection)) continue; } //if no intersection continue else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection)) continue; //get closest intersection let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; } } //check if map is circular if(map.circle) { //if circular map has generated points (besides tangent points to ray) if(map._points.length &gt; 0) { continue; } //check if target point is a circle tangent point to ray if(options.target) { let points = map.getPoints(this); let isTangent = false; for(let point of points) { if(Phaser.Geom.Point.Equals(options.target, point)) { //get closest intersection let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = point; isTangent = true; break; } } } if(isTangent) continue; } let circleIntersections = []; let offset = new Phaser.Geom.Point(); offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5); offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5); //calculate circle's center after rotation let rotation = map.object.rotation; if(rotation !== 0) { let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y); Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector)); let cB = vector.getPointB(); offset.x = cB.x; offset.y = cB.y; } //create transformed circle let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX); if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) { for(let intersection of circleIntersections) { //get closest intersection let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; } } } } } let result; if(!closestIntersection) { if(this.ignoreNotIntersectedRays) return false; result = this._ray.getPointB(); } else { result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y); } if(this.round) { result.x = Math.round(result.x); result.y = Math.round(result.y); } return result; } Ã— Search results Close Phaser-raycaster "},"ray_castCircle.js.html":{"id":"ray_castCircle.js.html","title":"Source: ray/castCircle.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/castCircle.js /** * Cast ray in all directions to find closest intersections with tested mapped objects. * * @method Raycaster.Ray#castCircle * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} [options] - options that may include: * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects. * * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. */ export function castCircle(options = {}) { let originalAngle = this.angle; let intersections = []; let maps = []; let rayTargets = []; let testedObjects = []; //if no objects to cast ray were passed, use raycasters mapped objects if(!options.objects) { if(this._raycaster) options.objects = this._raycaster.mappedObjects; else return intersections; //if bounding box is defined add bounding box points to if(this._raycaster &amp;&amp; this._raycaster.boundingBox) { for(let point of this._raycaster.boundingBox.points) { rayTargets.push({ point: point, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y) }); } } for(let i=0, iLength = options.objects.length; i &lt; iLength; i++) { let object = options.objects[i]; //if bound in range if(!this.boundsInRange(object)) continue; testedObjects.push(object); let map; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else map = object.data.get('raycasterMap'); maps.push(map); //get points and angles for(let point of map.getPoints(this)) { rayTargets.push({ point: point, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y) }); } //get objects intersections for(let j = i+1, jLength = options.objects.length; j &lt; jLength; j++){ let objectB = options.objects[j]; let mapB; if(objectB.type === 'body' || objectB.type === 'composite') mapB = objectB.raycasterMap; else { mapB = objectB.data.get('raycasterMap'); } //check if bounding boxes overlap if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox())) continue; //find objects intersections for(let segmentA of map.getSegments(this)) { for(let segmentB of mapB.getSegments(this)) { let intersection = []; if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection)) continue; rayTargets.push({ point: new Phaser.Geom.Point(intersection.x, intersection.y), angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y) }); } } } } //sort target points by angle rayTargets.sort(function(a, b){ //if rays towards points have the same angles promote closer one if(a.angle == b.angle) { if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) &gt; Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y)) return 1; else return -1; } return a.angle - b.angle; }.bind(this)); let previousTarget = { angle: false }; //cast rays for(let target of rayTargets){ //if current target is the same as previous one skip loop if(target.angle === previousTarget.angle) { continue; } previousTarget = target; this.setAngle(target.angle); let intersection = this.cast({ objects: testedObjects, target: target.point }); if(intersection){ //if intersection hits target point cast two additional rays let castSides = false; if(this.round) { let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y)); castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection) } else { castSides = Phaser.Geom.Point.Equals(target.point, intersection); } if(castSides) { this.setAngle(target.angle - 0.0001); let intersectionA = this.cast({ objects: testedObjects }); if(intersectionA) { intersections.push(intersectionA); } intersections.push(intersection); this.setAngle(target.angle + 0.0001); let intersectionB = this.cast({ objects: testedObjects }); if(intersectionB) { intersections.push(intersectionB); } continue; } intersections.push(intersection); } } } this.setAngle(originalAngle); this.intersections = intersections; if(this.autoSlice) this.slicedIntersections = this.slice(); return intersections; } Ã— Search results Close Phaser-raycaster "},"ray_castCone.js.html":{"id":"ray_castCone.js.html","title":"Source: ray/castCone.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/castCone.js /** * Cast ray in a cone to find closest intersections with tested mapped objects. * * @method Raycaster.Ray#castCone * @memberof Raycaster.Ray * @instance * @since 0.7.0 * * @param {object} [options] - options that may include: * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects. * * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. */ export function castCone(options = {}) { let originalAngle = this.angle; let intersections = []; let maps = []; let rayTargets = []; let testedObjects = []; let cone = this.cone; let minAngle = 0; let maxAngle = 0; let angleOffset = 0; //set cone if(options.cone !== undefined) cone = options.cone; if(options.coneDeg !== undefined) cone = Phaser.Math.DegToRad(options.coneDeg); //set cone min and max angle minAngle = this.angle - cone / 2; maxAngle = this.angle + cone / 2; //add min and max angle points this.setAngle(minAngle); rayTargets.push({ point: this._ray.getPointB(), angle: minAngle, angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2) }); this.setAngle(maxAngle); rayTargets.push({ point: this._ray.getPointB(), angle: maxAngle, angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2) }); //if no objects to cast ray were passed, use raycasters mapped objects if(!options.objects) { if(this._raycaster) options.objects = this._raycaster.mappedObjects; else return intersections; //if bounding box is defined add bounding box points to if(this._raycaster &amp;&amp; this._raycaster.boundingBox) { for(let point of this._raycaster.boundingBox.points) { let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y); let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle)); if(Math.abs(angleOffsetDeg) &lt; Phaser.Math.RadToDeg(cone / 2)) { rayTargets.push({ point: point, angle: angle, angleOffsetDeg: -angleOffsetDeg }); } } } } for(let i=0, iLength = options.objects.length; i &lt; iLength; i++) { let object = options.objects[i]; //if bound in range if(!this.boundsInRange(object)) continue; testedObjects.push(object); let map; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else map = object.data.get('raycasterMap'); maps.push(map); //get points and angles for(let point of map.getPoints(this)) { let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y); let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle)); if(Math.abs(angleOffsetDeg) &lt; Phaser.Math.RadToDeg(cone / 2)) { rayTargets.push({ point: point, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y), angleOffsetDeg: -angleOffsetDeg }); } } //get objects intersections for(let j = i+1, jLength = options.objects.length; j &lt; jLength; j++){ let objectB = options.objects[j]; let mapB; if(objectB.type === 'body' || objectB.type === 'composite') mapB = objectB.raycasterMap; else mapB = objectB.data.get('raycasterMap'); //check if bounding boxes overlap if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox())) continue; //find objects intersections for(let segmentA of map.getSegments(this)) { for(let segmentB of mapB.getSegments(this)) { let intersection = []; if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection)) continue; let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y); let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle)); if(Math.abs(angleOffsetDeg) &lt; Phaser.Math.RadToDeg(cone / 2)) { rayTargets.push({ point: new Phaser.Geom.Point(intersection.x, intersection.y), angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y), angleOffsetDeg: -angleOffsetDeg }); } } } } } //sort target points by angle rayTargets.sort(function(a, b){ //if rays towards points have the same angles promote closer one if(a.angle == b.angle) { if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) &gt; Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y)) return 1; else return -1; } return a.angleOffsetDeg - b.angleOffsetDeg; }.bind(this)); let previousTarget = { angle: false }; //cast rays for(let target of rayTargets){ //if current target is the same as previous one skip loop if(target.angle === previousTarget.angle) { continue; } previousTarget = target; this.setAngle(target.angle); let intersection = this.cast({ objects: testedObjects, target: target.point }); if(intersection){ //if intersection hits target point cast two additional rays let castSides = false; if(this.round) { let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y)); castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection) } else { castSides = Phaser.Geom.Point.Equals(target.point, intersection); } if(castSides) { this.setAngle(target.angle - 0.0001); let intersectionA = this.cast({ objects: testedObjects }); if(intersectionA) { intersections.push(intersectionA); } intersections.push(intersection); this.setAngle(target.angle + 0.0001); let intersectionB = this.cast({ objects: testedObjects }); if(intersectionB) { intersections.push(intersectionB); } continue; } intersections.push(intersection); } } this.setAngle(originalAngle); this.intersections = intersections; if(this.autoSlice) this.slicedIntersections = this.slice(intersections, false); return intersections; } Ã— Search results Close Phaser-raycaster "},"ray_ray.js.html":{"id":"ray_ray.js.html","title":"Source: ray/ray.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/ray.js /** * Set ray's position, direction (angle) and range. * * @method Raycaster.Ray#setRay * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {integer} x - X coordinate. * @param {integer} y - Y coordinate. * @param {float} [angle] - Ray's angle in radians. * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) { this.origin.setTo(x, y); this.angle = Phaser.Math.Angle.Normalize(angle); this.rayRange = rayRange; Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange); return this; } Ã— Search results Close Phaser-raycaster "},"ray_origin.js.html":{"id":"ray_origin.js.html","title":"Source: ray/origin.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/origin.js /** * Set ray's source position. * * @method Raycaster.Ray#setOrigin * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {integer} x - X coordinate. * @param {integer} y - Y coordinate. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setOrigin(x, y) { this.origin.setTo(x, y); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange); if(this.bodyType === 'matter' &amp;&amp; this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) { this.collisionCircle.x = x; this.collisionCircle.y = y; } else if(this.bodyType === 'arcade') { this.collisionCircle.x = x; this.collisionCircle.y = y; } return this; } Ã— Search results Close Phaser-raycaster "},"ray_angle.js.html":{"id":"ray_angle.js.html","title":"Source: ray/angle.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/angle.js /** * Set ray's angle (direction) in radians. * * @method Raycaster.Ray#setAngle * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {float} [angle = 0] - Ray's angle in radians. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setAngle(angle = 0) { this.angle = Phaser.Math.Angle.Normalize(angle); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); return this; } /** * Set ray's angle (direction) in degrees. * * @method Raycaster.Ray#setAngleDeg * @memberof Raycaster.Ray * @instance * @since 0.6.1 * * @param {float} [angle = 0] - Ray's angle in degrees. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setAngleDeg(angle = 0) { this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle)); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); return this; } Ã— Search results Close Phaser-raycaster "},"ray_range.js.html":{"id":"ray_range.js.html","title":"Source: ray/range.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/range.js /** * Set ray's range. * * @method Raycaster.Ray#setRayRange * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) { this.rayRange = rayRange; Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); return this; } /** * Set ray's maximum detection range. Objects outside detection range won't be tested. * Ray tests all objects when set to 0. * * @method Raycaster.Ray#setDetectionRange * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setDetectionRange(detectionRange = 0) { this.detectionRange = detectionRange; this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange); return this; } /** * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method. * Determines ray's physics body radius. * * @method Raycaster.Ray#setCollisionRange * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) { let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER; this.collisionRange = collisionRange; this.collisionCircle.setRadius(this.collisionRange); if(this.bodyType === 'matter') { if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) { let bounds = this._raycaster.boundingBox; this._raycaster.scene.matter.body.set(this.body, { shape: { type: 'rectangle', x: bounds.rectangle.centerX, y: bounds.rectangle.centerY, width: bounds.rectangle.width, height: bounds.rectangle.height, circleRadius:0 } }); } else if(oldRangeMax) { this._raycaster.scene.matter.body.set(this.body, { shape: { type: 'circle', x: this.collisionCircle.x, y: this.collisionCircle.y }, circleRadius: this.collisionRange, isStatic: false }); } else { this.collisionCircle.setRadius(this.collisionRange); } this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange) } else if(this.bodyType === 'arcade') { this.body.setCircle(this.collisionRange); } return this; } /** * Test if object's bounding box is in ray's detection range. * * @method Raycaster.Ray#boundsInRange * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} object - Tested object * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically. * * @return {boolean} Information if object is in ray's detection range. */ export function boundsInRange(object, bounds = false) { if(!this.detectionRange) return true; let objectBounds; if(bounds) objectBounds = bounds; else { if(object.type === 'body' || object.type === 'composite') objectBounds = object.raycasterMap.getBoundingBox(); else objectBounds = object.data.get('raycasterMap').getBoundingBox(); } if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds)) return true; return false; } Ã— Search results Close Phaser-raycaster "},"ray_cone.js.html":{"id":"ray_cone.js.html","title":"Source: ray/cone.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/cone.js /** * Set ray's cone angle (width) in radians. * * @method Raycaster.Ray#setCone * @memberof Raycaster.Ray * @instance * @since 0.7.0 * * @param {float} [cone = 0] - Ray's cone angle in radians. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCone(cone = 0) { this.cone = cone; return this; } /** * Set ray's cone angle (width) in degrees. * * @method Raycaster.Ray#setConeDeg * @memberof Raycaster.Ray * @instance * @since 0.7.0 * * @param {float} [cone = 0] - Ray's cone angle in degrees. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setConeDeg(cone = 0) { this.cone = Phaser.Math.DegToRad(cone); return this; } Ã— Search results Close Phaser-raycaster "},"ray_overlap.js.html":{"id":"ray_overlap.js.html","title":"Source: ray/overlap.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/overlap.js /** * Get game objects overlaping field of view. * * @method Raycaster.Ray#overlap * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {object|object[]} [objects] - Game object / array off game objects to test. * * @return {object[]} Array of game objects that overlaps with field of view. */ export function overlap(objects) { let targets = []; let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange); //matter physics if(this.bodyType === 'matter') { let isCollisionInfo = false; if(objects === undefined) { objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies()); for(let object of objects) { let body = object.bodyA === this.body ? object.bodyB : object.bodyA; if(this.testMatterOverlap(body)) targets.push(body); } } //get object's body else { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { if(object === this.body) continue; if(this.testMatterOverlap(object)) targets.push(object); } } } //arcade physics else { //get bodies in range if(objects === undefined) { objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true); bodies = true; } //get object's body else if(!Array.isArray(objects)) { objects = [objects]; } //if objects are bodies if(bodies) { for(let body of objects) { if(body === this.body) continue; let hitbox; //get physics body hitbox if(body.isCircle) { hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth); } else { hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height); } if(this.testOverlap(hitbox)) targets.push(body.gameObject); } } //if objects are game objects else { for(let object of objects) { if(object.body === undefined) continue; let hitbox; //get physics body hitbox if(object.body.isCircle) { hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth); if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox)) continue; } else { hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height); if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox)) continue; } if(this.testArcadeOverlap(hitbox)) targets.push(object); } } } return targets; } /** * Process callback for physics collider / overlap. * * @method Raycaster.Ray#processOverlap * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object. * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument. * * @return {boolean} Return true if game object is overlapping ray's field of view. */ export function processOverlap(object1, object2) { let target; //check if it's matter collisionInfo object if(object1.bodyA !== undefined &amp;&amp; object1.bodyB !== undefined) { object2 = object1.bodyB; object1 = object1.bodyA; } if(object1._ray !== undefined &amp;&amp; object1._ray === this) target = object2; else if(object2._ray !== undefined &amp;&amp; object2._ray === this) target = obj1; else return false; return (this.overlap(target).length &gt; 0); } /** * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}. * * @method Raycaster.Ray#testArcadeOverlap * @memberof Raycaster.Ray * @instance * @private * @since 0.8.0 * * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}. * * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view. */ export function testArcadeOverlap(hitbox) { let overlap = false; //iterate through field of view slices to check collisions with target for(let slice of this.slicedIntersections) { //if hitbox is a circle if(hitbox.type == 0) { overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox); } //if hitbox is a rectangle else { overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice); } if(overlap) { return true; } } return false; } /** * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}. * * @method Raycaster.Ray#testMatterOverlap * @memberof Raycaster.Ray * @instance * @private * @since 0.9.0 * * @param {object} body - Matter body. * * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view. */ export function testMatterOverlap(object) { let overlap = false; let body; if(object.type === 'body') body = object; else if(object.body !== undefined) body = object.body; else return false; //if body is concave, ignore convex body let parts = body.parts.length &gt; 1 ? body.parts.splice(1) : body.parts; //iterate through bodies for(let part of parts) { let pointA = part.vertices[0]; for(let i = 1, length = part.vertices.length; i &lt; length; i++) { let pointB = part.vertices[i]; let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y); //iterate through field of view slices to check collisions with target for(let slice of this.slicedIntersections) { let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment); //additional checking if slice contain segment's points due to TriangleToLine bug. if(!overlap) overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA()); if(!overlap) overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB()); if(overlap) { return true; } } pointA = pointB; } //closing segment let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y); //iterate through field of view slices to check collisions with target for(let slice of this.slicedIntersections) { let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment); if(overlap) { return true; } } } return false; } Ã— Search results Close Phaser-raycaster "},"ray_enablePhysics.js.html":{"id":"ray_enablePhysics.js.html","title":"Source: ray/enablePhysics.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/enablePhysics.js /** * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once. * * @method Raycaster.Ray#enablePhysics * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function enablePhysics(type = 'arcade') { if(this.body !== undefined) return this; if(type === 'matter') { this.bodyType = 'matter'; this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange); this.collisionCircle._ray = this; if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) { let bounds = this._raycaster.boundingBox; this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true }); } else { this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true }); } this.body = this.collisionCircle.body; this.body._ray = this; } else { this.bodyType = 'arcade'; this._raycaster.scene.physics.add.existing(this.collisionCircle); this.body = this.collisionCircle.body; this.body .setCircle(collisionRange) .setAllowGravity(false) .setImmovable(true); this.body._ray = this; } return this; } Ã— Search results Close Phaser-raycaster "},"map_map-core.js.html":{"id":"map_map-core.js.html","title":"Source: map/map-core.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/map-core.js /** * @classdesc * * Map class responsible for mapping game objects. * * @namespace Raycaster.Map * @class Raycaster.Map * @constructor * @since 6.0.0 * * @param {object} options - Map specific configuration settings. * @param {Raycaster} [raycaster] - Parent raycaster object. */ export function Map(options, raycaster) { /** * Reference to parent Raycaster object. * * @name Raycaster.Map#_raycaster * @type {Raycaster} * @private * @since 0.9.0 */ this._raycaster = raycaster ? raycaster : false; /** * Mapped object's type * * @name Raycaster.Map#type * @type {string} * @readonly * @since 0.6.0 */ this.type; /** * If set true, map will be tested by ray. Otherwise it will be ignored. * * @name Raycaster.Map#active * @type {boolean} * @default true * @since 0.7.2 */ this.active; /** * If set true, map will be automatically updated on scene update event. * * @name Raycaster.Map#dynamic * @type {boolean} * @default false * @since 0.6.0 */ this.dynamic; /** * If set true, map will be treated by ray as circle. Set automaticalyy on map update. * * @name Raycaster.Map#circle * @type {boolean} * @default false * @since 0.9.0 */ this.circle = false; /** * Reference to mapped object. * * @name Raycaster.Map#object * @type {object} * @readonly * @since 0.6.0 */ this.object; /** * Array of mapped object's vertices used as rays targets. * * @name Raycaster.Map#_points * @type {array} * @private * @since 0.6.0 */ this._points = []; /** * Array of mapped object's segments used to test object's intersection with ray. * * @name Raycaster.Map#_segments * @type {array} * @private * @since 0.6.0 */ this._segments = []; /** * Get array of mapped object's vertices used as rays targets. * * @method Raycaster.Map#getPoints * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Point[]} Array of mapped object's vertices. */ this.getPoints; /** * Get array of mapped object's segments used to test object's intersection with ray. * * @method Raycaster.Map#getSegments * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Line[]} Array of mapped object's segments. */ this.getSegments; /** * Get mapped object's bounding box. * * @method Raycaster.Map#getBoundingBox * @memberof Raycaster.Map * @instance * @since 0.9.0 * * @return {Phaser.Geom.Rectangle} Mapped object's bounding box. */ this.getBoundingBox; /** * Update object's map of points and segments. * * @method Raycaster.Map#updateMap * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ this.updateMap; this.config(options); this.updateMap(); return this; }; Map.prototype = { config: require('./config.js').config }; Map.prototype.constructor = Map; Ã— Search results Close Phaser-raycaster "},"map_config.js.html":{"id":"map_config.js.html","title":"Source: map/config.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/config.js let rectangle = require('./map-rectangle-methods.js'); let line = require('./map-line-methods.js'); let polygon = require('./map-polygon-methods.js'); let arc = require('./map-circle-methods.js'); let container = require('./map-container-methods.js'); let tilemap = require('./map-tilemap-methods.js'); let matterBody = require('./map-matterBody-methods.js'); let segmentCount = require('./segmentsCount.js'); let boundingBox = require('./boundingBox.js'); /** * Configure map. * * @method Raycaster.Map#config * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {object} [options] - Map's congfiguration options. May include: * @param {object} options.object - Game object to map * @param {string} [options.type] - Map type. If not defined, it will be determined based on object. * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event). * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated). * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies. * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies. * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function config(options) { this.object = options.object; //object type if(options.type === undefined) options.type = options.object.type; if(options.type === 'body' || options.type === 'composite') options.type = 'MatterBody'; this.type = options.type; switch(options.type) { case 'Polygon': this.getPoints = polygon.getPoints; this.getSegments = polygon.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = polygon.updateMap; break; case 'Arc': //circle segments count this.segmentCount = (options.segmentCount) ? options.segmentCount : 0; this.circle = (options.segmentCount) ? false : true; this.getPoints = arc.getPoints; this.getSegments = arc.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = arc.updateMap; this.setSegmentCount = segmentCount.setSegmentCount; break; case 'Line': this.getPoints = line.getPoints; this.getSegments = line.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = line.updateMap; break; case 'Container': this.getPoints = container.getPoints; this.getSegments = container.getSegments; this.updateMap = container.updateMap; break; case 'StaticTilemapLayer': //ray colliding tiles this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : []; this.getPoints = tilemap.getPoints; this.getSegments = tilemap.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = tilemap.updateMap; this.setCollisionTiles = tilemap.setCollisionTiles; //reset tilemap origin this.object.setOrigin(0,0); break; case 'DynamicTilemapLayer': //ray colliding tiles this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : []; this.getPoints = tilemap.getPoints; this.getSegments = tilemap.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = tilemap.updateMap; this.setCollisionTiles = tilemap.setCollisionTiles; //reset tilemap origin this.object.setOrigin(0,0); break; case 'MatterBody': //force convex body (hull) mapping this.forceConvex = (options.forceConvex) ? true : false; //force mapping by vertices this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false; this.circle = false; this.getPoints = matterBody.getPoints; this.getSegments = matterBody.getSegments; this.getBoundingBox = matterBody.getBoundingBox; this.updateMap = matterBody.updateMap; break; default: this.getPoints = rectangle.getPoints; this.getSegments = rectangle.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = rectangle.updateMap; } //dynamic map this.dynamic = (options.dynamic == true) ? true : false; //enable/disable map this.active = (options.active !== undefined) ? options.active : true; return this; } Ã— Search results Close Phaser-raycaster "},"map_segmentsCount.js.html":{"id":"map_segmentsCount.js.html","title":"Source: map/segmentsCount.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/segmentsCount.js /** * Set segment count for cirle's map. * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. * * @method Raycaster.Map#setSegmentCount * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {integer} count - Circle map's segment count. * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function setSegmentCount(count) { this.segmentCount = count; this.circle = count ? false : true; this.updateMap(); return this; } Ã— Search results Close Phaser-raycaster "},"map_map-tilemap-methods.js.html":{"id":"map_map-tilemap-methods.js.html","title":"Source: map/map-tilemap-methods.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/map-tilemap-methods.js /*Map methods for tilemaps*/ /** * Get array of mapped tilemap's vertices used as rays targets. * * @method Raycaster.Map#tilemap.getPoints * @memberof Raycaster.Map * @instance * @private * @since 0.7.3 * * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Point[]} - Array of mapped object's vertices. */ export function getPoints(ray = false) { if(!this.active) return []; if(!ray || ray &amp;&amp; (ray.detectionRange == 0 || ray.detectionRange &gt;= Phaser.Math.MAX_SAFE_INTEGER)) return this._points; let points = []; for(let point of this._points) { if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) &lt;= ray.detectionRange) points.push(point); } //get intersections between tilemap's segments and ray's detection range edge let segments = this.getSegments(ray); for(let segment of segments) { if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) &gt; ray.detectionRange) points.push(new Phaser.Geom.Point(segment.x1, segment.y1)); if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) &gt; ray.detectionRange) points.push(new Phaser.Geom.Point(segment.x2, segment.y2)); } return points; }; /** * Get array of mapped tilemap's segments used to test object's intersection with ray. * * @method Raycaster.Map#tilemap.getSegments * @memberof Raycaster.Map * @instance * @private * @since 0.7.3 * * @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Line[]} - Array of mapped object's segments. */ export function getSegments(ray = false) { if(!this.active) return []; if(!ray || ray &amp;&amp; (ray.detectionRange == 0 || ray.detectionRange &gt;= Phaser.Math.MAX_SAFE_INTEGER)) return this._segments; let segments = []; for(let segment of this._segments) { if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) { segments.push(segment); } } return segments; }; /** * Update tilemap's map of points and segments. * * @method Raycaster.Map#tilemap.updateMap * @memberof Raycaster.Map * @instance * @private * @since 0.7.3 * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function updateMap() { if(!this.active) return this; let points = []; let segments = []; //calculate offset based on object position and origin point let offset = new Phaser.Geom.Point(); offset.x = this.object.x; offset.y = this.object.y; let horizontal = false; let horizontals = []; let verticals = []; //iterate rows for(let i = 0, iLength = this.object.layer.data.length; i &lt; iLength; i++) { let row = this.object.layer.data[i]; //iterate row's tiles for(let j = 0, jLength = row.length; j &lt; jLength; j++) { let tile = row[j]; //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking) let upperEdge = ((i &gt; 0 &amp;&amp; this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 &amp;&amp; this.collisionTiles.includes(tile.index))) ? true : false; let leftEdge = ((j &gt; 0 &amp;&amp; this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 &amp;&amp; this.collisionTiles.includes(tile.index))) ? true : false; //get current tile's column last vertical line let vertical = false; if(verticals.length &lt;= j) verticals[j] = []; else if(verticals[j].length &gt; 0) vertical = verticals[j][verticals[j].length - 1]; //check if tile has edge from left if(leftEdge) { if(vertical &amp;&amp; vertical.y + vertical.height == i) vertical.height++; else { verticals[j].push({ x: tile.x, y: tile.y, height: 1 }); } } //check if tile has edge from top if(upperEdge) { if(horizontal) horizontal.width++; else horizontal = { x: tile.x, y: tile.y, width: 1 }; continue; } if(horizontal) { let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x; let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y; let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y); segments.push(segment); horizontals.push(segment); points.push(new Phaser.Geom.Point(x, y)); points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y)); horizontal = false; } } //at the end of row add segment if exist if(horizontal) { let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x; let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y; let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y); segments.push(segment); horizontals.push(segment); points.push(new Phaser.Geom.Point(x, y)); points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y)); horizontal = false; } } //add bottom horizontal segments for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) { if(this.collisionTiles.includes(tile.index)) { if(horizontal) horizontal.width++; else horizontal = { x: tile.x, y: tile.y + 1, width: 1 }; continue; } if(horizontal) { let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x; let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y; let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y); segments.push(segment); horizontals.push(segment); points.push(new Phaser.Geom.Point(x, y)); points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y)); horizontal = false; } } //add segment if exist if(horizontal) { let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x; let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y; let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y); segments.push(segment); horizontals.push(segment); points.push(new Phaser.Geom.Point(x, y)); points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y)); horizontal = false; } //add right vertical segments let vertical = false; let verticalsLastColumn = []; for(let row of this.object.layer.data) { let tile = row[row.length - 1]; //if tile blocks ray if(this.collisionTiles.includes(tile.index)) { if(vertical) { vertical.height++; } else { vertical = { x: tile.x + 1, y: tile.y, height: 1 }; } continue; } if(vertical) { verticalsLastColumn.push(vertical); vertical = false; } } verticals.push(verticalsLastColumn); //add vertical segments for(let column of verticals) { if(!column) continue; for(let vertical of column) { let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x; let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y; let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height; let segment = new Phaser.Geom.Line(x, y1, x, y2) segments.push(segment); //add points if they're not already there if(!points.filter(point =&gt; point.x == x &amp;&amp; point.y == y1)) points.push(new Phaser.Geom.Point(x, y)); if(!points.filter(point =&gt; point.x == x &amp;&amp; point.y == y2)) points.push(new Phaser.Geom.Point(x, y)); //get intersections between horizontal segments and vertical for(let horizontalSegment of horizontals) { if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2) continue; if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2) continue; let point = new Phaser.Geom.Point(); if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) { points.push(point); } } } } this._points = points; this._segments = segments; return this; }; /** * Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only). * * @method Raycaster.Map#setCollisionTiles * @memberof Raycaster.Map * @instance * @since 0.7.3 * * @param {array} [tiles = []] - Set of tile's indexes to map. * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function setCollisionTiles(tiles = []) { this.collisionTiles = tiles; return this; } Ã— Search results Close Phaser-raycaster "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Classes Classes Raycaster Ray Map Ã— Search results Close Phaser-raycaster "},"index.html":{"id":"index.html","title":"Index","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Phaser Raycaster Raycasting plugin for Phaser 3. Phaser Raycaster is a Phaser 3 plugin which provide raycasting for geometric game objects, sprites and Matter.js bodies. It can be used with arcade physics Matter.js. Documentation: https://wiserim.github.io/phaser-raycaster/ Code examples are available on CodePen: LINK Features: compatible with arcade and matter physics, raycasting in a single direction, 360 degrees circle or in a cone, visibility detection (collision detection with game objects), test rays on mapped game objects (containers, lines, rectangles, polygons, circles, sprites, tilemaps and matter bodies), provides closest intersection points between rays and tested objects, tests can be made on all mapped objects, selected ones or only ones within detection range, static and dynamic mapping for individual objects, mapped objects intersections detection. NPM npm install phaser-raycaster CDN https://www.jsdelivr.com/package/npm/phaser-raycaster Getting started 1. Include plugin in your project: &lt;!--CDN--&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/phaser-raycaster@0.9.0/dist/phaser-raycaster.min.js\"&gt;&lt;/script&gt; # NPM npm install phaser-raycaster 2. Enable plugin in your Game config: let config = { type: Phaser.Auto, parent: 'game', width: 800, height: 600, backgroundColor: \"black\", scene: [ Scene1 ], plugins: { scene: [ { key: 'PhaserRaycaster', plugin: PhaserRaycaster, mapping: 'raycasterPlugin' } ] } } new Phaser.Game(config); 3. Create new raycaster in your scene: create() { this.raycaster = this.raycasterPlugin.createRaycaster(options); // additional code } 4. Create new ray create() { // additional code this.ray = this.raycaster.createRay(); // additional code } 5. Map game objects which will be tested by rays //create game object this.rectangle = this.add.rectangle(100, 100, 50, 50) .setStrokeStyle(1, 0xff0000); //map game object this.raycaster.mapGameObjects(this.rectangle); //create group this.group = this.add.group(); //map game objects actually in group this.raycaster.mapGameObjects(this.group.getChildren()); //map tilemap layer this.map = this.make.tilemap(); this.tilemap = this.map.createStaticLayer(); this.raycaster.mapGameObjects(this.tilemap, false, { collisionTiles: [1,2,3] //array of tiles types which can collide with ray }); 6. Cast ray //set ray position this.ray.setOrigin(400, 300); //set ray direction (in radians) this.ray.setAngle(2); //set ray direction (in degrees) this.ray.setAngleDeg(90); //cast single ray and get closets intersection with mapped objects let intersection = this.ray.cast(); //cast rays in all directions (toward all mapped objects vertices / points) let intersections = this.ray.castCircle(); //set ray's cone angle (in radians) this.ray.setCone(1); //set ray's cone angle (in degrees) this.ray.setCone(90); //cast rays in a cone let intersections = this.ray.castCone(); 7. Collisions (arcade physics) //enable auto slicing filed of view this.ray.autoSlice = true; //enable arcade physics body this.ray.enablePhysics(); //set collision (field of view) range this.ray.setCollisionRange(200); //cast ray this.ray.castCircle(); //get all game objects in field of view (which bodies overlap ray's field of view) let visibleObjects = this.ray.overlap(); //get objects in field of view visibleObjects = this.ray.overlap(group.getChildren()); //check if object is in field of view visibleObjects = this.ray.overlap(gameObject); //add overlap collider (require passing ray.processOverlap as process callback) this.physics.add.overlap(this.ray, targets, function(rayFoVCircle, target){ /* * what to do in game objects in line of sight */ }, this.ray.processOverlap.bind(this.ray)); 8. Collisions (matter physics) //enable auto slicing filed of view this.ray.autoSlice = true; //enable matter physics body this.ray.enablePhysics('matter'); //cast ray this.ray.castCircle(); //get all game objects and bodies in field of view (which bodies overlap ray's field of view) let visibleObjects = this.ray.overlap(); //get objects and bodies in field of view visibleObjects = this.ray.overlap([gameObject1, gameObject2, body1, body2]); //check if object is in field of view visibleObjects = this.ray.overlap(gameObject); //add collider (require passing ray.overlap in callback to check if body's in field of view) this.ray.body.setOnCollideWith(body, function(body){ let overlap = this.ray.overlap(body); if(overlap) { /* * what to do in game objects in line of sight */ } }); Ã— Search results Close Phaser-raycaster "},"Raycaster.html":{"id":"Raycaster.html","title":"Class: Raycaster","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Class: Raycaster Raycaster Raycaster class responsible for creating ray objects and managing mapped objects. new Raycaster( [options]) Parameters: Name Type Argument Description options object &lt;optional&gt; Raycaster's configuration options. May include: Properties Name Type Argument Default Description scene Phaser.Scene &lt;optional&gt; Scene in which Raycaster will be used. mapSegmentCount integer &lt;optional&gt; 0 Number of segments of circle maps. If set to 0, map will be teste objects object | Array.&lt;object&gt; &lt;optional&gt; Game object or array of game objects to map. boundingBox Phaser.Geom.Rectangle &lt;optional&gt; Raycaster's bounding box. autoUpdate boolean &lt;optional&gt; true If set true, automatically update dynamic maps on scene update event. Since: 6.0.0 Source: raycaster-core.js, line 7 Classes Ray Map Members &lt;readonly&gt; version :string Plugin version. Type: string Since: 0.6.0 Source: raycaster-core.js, line 25 mappedObjects :Array.&lt;object&gt; Array of mapped game objects. Type: Array.&lt;object&gt; Since: 0.6.0 Source: raycaster-core.js, line 55 mapSegmentCount :integer Number of segments of circle maps. Type: integer Since: 0.6.0 Default Value: 0 Source: raycaster-core.js, line 64 Methods setOptions( [options]) Configure raycaster. Parameters: Name Type Argument Description options object &lt;optional&gt; Raycaster's congfiguration options. May include: Properties Name Type Argument Default Description scene Phaser.Scene &lt;optional&gt; Scene in which Raycaster will be used. mapSegmentCount integer &lt;optional&gt; 0 Number of segments of circle maps. objects object | Array.&lt;object&gt; &lt;optional&gt; Game object or array of game objects to map. boundingBox Phaser.Geom.Rectangle &lt;optional&gt; Raycaster's bounding box. Since: 0.6.0 Source: raycaster-core.js, line 106 Returns: Raycaster instance Type Raycaster setBoundingBox(x, y, width, height) Set Raycatser's bounding box. Parameters: Name Type Description x integer The X coordinate of the top left corner of bounding box. y integer The Y coordinate of the top left corner of bounding box. width integer The width of bounding box. height integer The height of bounding box. Since: 0.6.0 Source: raycaster-core.js, line 140 Returns: Raycaster instance Type Raycaster mapGameObjects(objects [, dynamic] [, options]) Map game objects Parameters: Name Type Argument Default Description objects object | Array.&lt;object&gt; Game object / matter body or array of game objects / matter bodies to map. dynamic boolean &lt;optional&gt; false Raycaster.Map dynamic flag (determines map will be updated automatically). options object &lt;optional&gt; Additional options for Raycaster.Map Since: 0.6.0 Source: raycaster-core.js, line 180 Returns: Raycaster instance Type Raycaster removeMappedObjects(objects) Remove game object's Raycaster.Map maps. Parameters: Name Type Description objects object | Array.&lt;object&gt; Game object or array of game objects which maps will be removed. Since: 0.6.0 Source: raycaster-core.js, line 226 Returns: Raycaster instance Type Raycaster enableMaps(objects) Enable game object's Raycaster.Map maps. Parameters: Name Type Description objects object | Array.&lt;object&gt; Game object or array of game objects which maps will be enabled. Since: 0.7.2 Source: raycaster-core.js, line 251 Returns: Raycaster instance Type Raycaster disableMaps(objects) Disable game object's Raycaster.Map maps. Parameters: Name Type Description objects object | Array.&lt;object&gt; Game object or array of game objects which maps will be disabled. Since: 0.7.2 Source: raycaster-core.js, line 284 Returns: Raycaster instance Type Raycaster update() Updates all Raycaster.Map dynamic maps. Fired on Phaser.Scene update event. Since: 0.6.0 Source: raycaster-core.js, line 317 createRay( [options]) Create Raycaster.Ray object. Parameters: Name Type Argument Description options object &lt;optional&gt; Ray options: Since: 0.6.0 Source: raycaster-core.js, line 347 Returns: Raycaster.Ray instance Type Raycaster.Ray Ã— Search results Close Phaser-raycaster "},"Raycaster.Ray.html":{"id":"Raycaster.Ray.html","title":"Class: Ray","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Class: Ray Raycaster. Ray Ray class responsible for casting ray's and testing their collisions with mapped objects. new Ray(options [, raycaster]) Parameters: Name Type Argument Description options object Ray specific configuration settings. raycaster Raycaster &lt;optional&gt; Parent raycaster object. Since: 6.0.0 Source: ray/ray-core.js, line 1 Members origin :Phaser.Geom.Point Ray's source position. Type: Phaser.Geom.Point Since: 0.6.0 Source: ray/ray-core.js, line 24 angle :float Ray's angle in radians. Type: float Since: 0.6.0 Default Value: 0 Source: ray/ray-core.js, line 41 cone :float Ray's cone width angle in radians. Type: float Since: 0.7.0 Default Value: 0 Source: ray/ray-core.js, line 50 rayRange :integer Ray's maximum range Type: integer Since: 0.6.0 Default Value: Phaser.Math.MAX_SAFE_INTEGER Source: ray/ray-core.js, line 59 detectionRange :integer Ray's maximum detection range. Objects outside detection range won't be tested. Ray tests all objects when set to 0. Type: integer Since: 0.6.0 Source: ray/ray-core.js, line 68 collisionRange :integer Ray's maximum collision range of ray's field of view. Radius of Ray.body. Type: integer Since: 0.8.0 Default Value: Phaser.Math.MAX_SAFE_INTEGER Source: ray/ray-core.js, line 87 ignoreNotIntersectedRays :boolean If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. Type: boolean Since: 0.6.0 Default Value: true Source: ray/ray-core.js, line 96 round :boolean If set true, ray's hit points will be rounded. Type: boolean Since: 0.8.1 Default Value: false Source: ray/ray-core.js, line 105 autoSlice :boolean If set true, ray will automatically slice intersections into array of triangles and store it in Ray.slicedIntersections. Type: boolean Since: 0.8.0 Default Value: false Source: ray/ray-core.js, line 114 intersections :Array.&lt;object&gt; Array of intersections from last raycast representing field of view. Type: Array.&lt;object&gt; Since: 0.8.0 Default Value: [] Source: ray/ray-core.js, line 123 slicedIntersections :Array.&lt;Phaser.Geom.Triangle&gt; Array of triangles representing slices of field of view from last raycast. Type: Array.&lt;Phaser.Geom.Triangle&gt; Since: 0.8.0 Default Value: [] Source: ray/ray-core.js, line 132 body :object Physics body for testing field of view collisions. Type: object Since: 0.8.0 Default Value: undefined Source: ray/ray-core.js, line 142 bodyType :bolean|'arcade'|'matter' Physics body type. Type: bolean | 'arcade' | 'matter' Since: 0.9.0 Default Value: false Source: ray/ray-core.js, line 151 Methods config( [options]) Configure ray. Parameters: Name Type Argument Description options object &lt;optional&gt; Ray's congfiguration options. May include: Properties Name Type Argument Default Description origin Phaser.Geom.Point &lt;optional&gt; {x:0, y:0} Ray's position. angle float &lt;optional&gt; 0 Ray's angle in radians. angleDeg float &lt;optional&gt; 0 Ray's angle in degrees. cone float &lt;optional&gt; 0 Ray's cone angle in radians. coneDeg float &lt;optional&gt; 0 Ray's cone angle in degrees. range integer &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. collisionRange integer &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's maximum collision range of ray's field of view. detectionRange integer &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Maximum distance between ray's position and tested objects bounding boxes. ignoreNotIntersectedRays boolean &lt;optional&gt; true If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. autoSlice boolean &lt;optional&gt; false If set true, ray will automatically slice intersections into array of triangles and store it in Ray.slicedIntersections. round boolean &lt;optional&gt; false If set true, point where ray hit will be rounded. enablePhysics boolean | 'arcade' | 'matter' &lt;optional&gt; false Add to ray physics body. Body will be a circle with radius equal to Ray.collisionRange. If set true, arcade physics body will be added. Since: 0.6.0 Source: ray/config.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray cast( [options]) Cast ray to find closest intersection with tested mapped objects. Parameters: Name Type Argument Description options object &lt;optional&gt; options that may include: Properties Name Type Argument Default Description objects Array.&lt;object&gt; &lt;optional&gt; {Raycaster#mappedObjects} Array of game objects to test. If not provided test all mapped game objects. target Phaser.Geom.Point &lt;optional&gt; Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point. Since: 0.6.0 Source: ray/cast.js, line 1 Returns: Ray's closest intersection with tested objects. Returns false if no intersection has been found. Type Phaser.Geom.Point | boolean castCircle( [options]) Cast ray in all directions to find closest intersections with tested mapped objects. Parameters: Name Type Argument Description options object &lt;optional&gt; options that may include: Properties Name Type Argument Default Description objects Array.&lt;object&gt; &lt;optional&gt; Raycaster.mappedObjects Array of game objects to test. If not provided test all mapped game objects. Since: 0.6.0 Source: ray/castCircle.js, line 1 Returns: Array of points of ray's closest intersections with tested objects. Type Array.&lt;Phaser.Geom.Point&gt; castCone( [options]) Cast ray in a cone to find closest intersections with tested mapped objects. Parameters: Name Type Argument Description options object &lt;optional&gt; options that may include: Properties Name Type Argument Default Description objects Array.&lt;object&gt; &lt;optional&gt; Raycaster.mappedObjects Array of game objects to test. If not provided test all mapped game objects. Since: 0.7.0 Source: ray/castCone.js, line 1 Returns: Array of points of ray's closest intersections with tested objects. Type Array.&lt;Phaser.Geom.Point&gt; setRay(x, y [, angle] [, range]) Set ray's position, direction (angle) and range. Parameters: Name Type Argument Default Description x integer X coordinate. y integer Y coordinate. angle float &lt;optional&gt; Ray's angle in radians. range integer &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. Since: 0.6.0 Source: ray/ray.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setOrigin(x, y) Set ray's source position. Parameters: Name Type Description x integer X coordinate. y integer Y coordinate. Since: 0.6.0 Source: ray/origin.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setAngle( [angle]) Set ray's angle (direction) in radians. Parameters: Name Type Argument Default Description angle float &lt;optional&gt; 0 Ray's angle in radians. Since: 0.6.0 Source: ray/angle.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setAngleDeg( [angle]) Set ray's angle (direction) in degrees. Parameters: Name Type Argument Default Description angle float &lt;optional&gt; 0 Ray's angle in degrees. Since: 0.6.1 Source: ray/angle.js, line 19 Returns: Raycaster.Ray instance Type Raycaster.Ray setRayRange( [rayRange]) Set ray's range. Parameters: Name Type Argument Default Description rayRange integer &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. Since: 0.6.0 Source: ray/range.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setDetectionRange( [detectionRange]) Set ray's maximum detection range. Objects outside detection range won't be tested. Ray tests all objects when set to 0. Parameters: Name Type Argument Default Description detectionRange integer &lt;optional&gt; 0 Maximum distance between ray's position and tested objects bounding boxes. Since: 0.6.0 Source: ray/range.js, line 19 Returns: Raycaster.Ray instance Type Raycaster.Ray setCollisionRange( [collisionRange]) Set ray's field of view maximum collision range. Objects outside collision range won't be tested by Raycaster.Ray.overlap method. Determines ray's physics body radius. Parameters: Name Type Argument Default Description collisionRange integer &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's collision range and physics body radius. Since: 0.8.0 Source: ray/range.js, line 39 Returns: Raycaster.Ray instance Type Raycaster.Ray boundsInRange(object [, bounds]) Test if object's bounding box is in ray's detection range. Parameters: Name Type Argument Default Description object object Tested object bounds Phaser.Geom.Rectangle | boolean &lt;optional&gt; false Tested object's bounds. If not passed bounds will be generated automatically. Since: 0.6.0 Source: ray/range.js, line 95 Returns: Information if object is in ray's detection range. Type boolean setCone( [cone]) Set ray's cone angle (width) in radians. Parameters: Name Type Argument Default Description cone float &lt;optional&gt; 0 Ray's cone angle in radians. Since: 0.7.0 Source: ray/cone.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setConeDeg( [cone]) Set ray's cone angle (width) in degrees. Parameters: Name Type Argument Default Description cone float &lt;optional&gt; 0 Ray's cone angle in degrees. Since: 0.7.0 Source: ray/cone.js, line 18 Returns: Raycaster.Ray instance Type Raycaster.Ray overlap( [objects]) Get game objects overlaping field of view. Parameters: Name Type Argument Description objects object | Array.&lt;object&gt; &lt;optional&gt; Game object / array off game objects to test. Since: 0.8.0 Source: ray/overlap.js, line 1 Returns: Array of game objects that overlaps with field of view. Type Array.&lt;object&gt; processOverlap(object1, object2) Process callback for physics collider / overlap. Parameters: Name Type Description object1 object Game object or matter body passed by collider / overlap or matter CollisionInfo object. object2 object Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument. Since: 0.8.0 Source: ray/overlap.js, line 102 Returns: Return true if game object is overlapping ray's field of view. Type boolean enablePhysics( [type]) Add to ray physics body. Body will be a circle with radius equal to Ray.collisionRange. Physics body can be added only once. Parameters: Name Type Argument Default Description type 'arcade' | 'matter' &lt;optional&gt; 'arcade' Physics type Since: 0.8.0 Source: ray/enablePhysics.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray Ã— Search results Close Phaser-raycaster "},"Raycaster.Map.html":{"id":"Raycaster.Map.html","title":"Class: Map","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Class: Map Raycaster. Map Map class responsible for mapping game objects. new Map(options [, raycaster]) Parameters: Name Type Argument Description options object Map specific configuration settings. raycaster Raycaster &lt;optional&gt; Parent raycaster object. Since: 6.0.0 Source: map/map-core.js, line 1 Members &lt;readonly&gt; type :string Mapped object's type Type: string Since: 0.6.0 Source: map/map-core.js, line 24 active :boolean If set true, map will be tested by ray. Otherwise it will be ignored. Type: boolean Since: 0.7.2 Default Value: true Source: map/map-core.js, line 33 dynamic :boolean If set true, map will be automatically updated on scene update event. Type: boolean Since: 0.6.0 Default Value: false Source: map/map-core.js, line 42 circle :boolean If set true, map will be treated by ray as circle. Set automaticalyy on map update. Type: boolean Since: 0.9.0 Default Value: false Source: map/map-core.js, line 51 &lt;readonly&gt; object :object Reference to mapped object. Type: object Since: 0.6.0 Source: map/map-core.js, line 60 Methods getPoints( [ray]) Get array of mapped object's vertices used as rays targets. Parameters: Name Type Argument Description ray Raycatser.Ray &lt;optional&gt; Raycaster.Ray object used in some some types of maps. Since: 0.6.0 Source: map/map-core.js, line 87 Returns: Array of mapped object's vertices. Type Array.&lt;Phaser.Geom.Point&gt; getSegments( [ray]) Get array of mapped object's segments used to test object's intersection with ray. Parameters: Name Type Argument Description ray Raycatser.Ray &lt;optional&gt; Raycaster.Ray object used in some some types of maps. Since: 0.6.0 Source: map/map-core.js, line 100 Returns: Array of mapped object's segments. Type Array.&lt;Phaser.Geom.Line&gt; getBoundingBox() Get mapped object's bounding box. Since: 0.9.0 Source: map/map-core.js, line 113 Returns: Mapped object's bounding box. Type Phaser.Geom.Rectangle updateMap() Update object's map of points and segments. Since: 0.6.0 Source: map/map-core.js, line 124 Returns: Raycaster.Map instance Type Raycaster.Map config( [options]) Configure map. Parameters: Name Type Argument Description options object &lt;optional&gt; Map's congfiguration options. May include: Properties Name Type Argument Default Description object object Game object to map type string &lt;optional&gt; Map type. If not defined, it will be determined based on object. dynamic boolean &lt;optional&gt; false If set true, map will be dynamic (updated on scene update event). active boolean &lt;optional&gt; true If set true, map will be active (will provide points, segments and will be updated). segmentCount integer &lt;optional&gt; Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. forceConvex boolean &lt;optional&gt; If set true, matter body map will use convex body (hull) for non-covex bodies. forceVerticesMapping boolean &lt;optional&gt; If set true, matter body map will use only vertices for mapping circle bodies. Since: 0.6.0 Source: map/config.js, line 11 Returns: Raycaster.Map instance Type Raycaster.Map setSegmentCount(count) Set segment count for cirle's map. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. Parameters: Name Type Description count integer Circle map's segment count. Since: 0.6.0 Source: map/segmentsCount.js, line 1 Returns: Raycaster.Map instance Type Raycaster.Map setCollisionTiles( [tiles]) Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only). Parameters: Name Type Argument Default Description tiles array &lt;optional&gt; [] Set of tile's indexes to map. Since: 0.7.3 Source: map/map-tilemap-methods.js, line 275 Returns: Raycaster.Map instance Type Raycaster.Map Ã— Search results Close Phaser-raycaster "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
