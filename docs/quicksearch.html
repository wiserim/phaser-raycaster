<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"raycaster-core.js.html":{"id":"raycaster-core.js.html","title":"Source: raycaster-core.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: raycaster-core.js /** * @author Marcin Walczak &lt;contact@marcin-walczak.pl&gt; * @copyright 2023 Marcin Walczak * @license {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License} */ /** * @classdesc * * Raycaster class responsible for creating ray objects and managing mapped objects. * * @namespace Raycaster * @class Raycaster * @constructor * @since 0.6.0 * * @param {object} [options] - Raycaster's configuration options. May include: * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used. * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste * @param {(object|object[])} [options.objects] - Game object or array of game objects to map. * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds. * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event. * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}. */ export function Raycaster(options) { /** * Plugin version. * * @name Raycaster#version * @type {string} * @readonly * @since 0.6.0 */ this.version = '0.10.10'; /** * Raycaster's scene * * @name Raycaster#scene * @type {Phaser.Scene} * @private * @since 0.6.0 */ this.scene; /** * Raycaster's graphics object used for debug * * @name Raycaster#graphics * @type {Phaser.GameObjects.Graphics} * @private * @since 0.10.0 */ this.graphics; /** * Raycaster's debug config * * @name Raycaster#debugOptions * @type {Object} * @since 0.10.0 * * @property {boolean} [enable = false] Enable debug mode * @property {boolean} [maps = true] - Enable maps debug * @param {boolean} [rays = true] - Enable rays debug * @property {boolean} graphics - Debug graphics options * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable. * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable. * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable. * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable. * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable. */ this.debugOptions = { enabled: false, maps: true, rays: true, graphics: { ray: 0x00ff00, rayPoint: 0xff00ff, mapPoint: 0x00ffff, mapSegment: 0x0000ff, mapBoundingBox: 0xff0000 } }; /** * Raycaster statistics. * * @name Raycaster.Raycaster#_stats * @type {object} * @private * @since 0.10.0 * * @property {object} mappedObjects Mapped objects statistics. * @property {number} mappedObjects.total Mapped objects total. * @property {number} mappedObjects.static Static maps. * @property {number} mappedObjects.dynamic Dynamic maps. * @property {number} mappedObjects.rectangleMaps Rectangle maps. * @property {number} mappedObjects.polygonMaps Polygon maps. * @property {number} mappedObjects.circleMaps Circle maps. * @property {number} mappedObjects.lineMaps Line maps. * @property {number} mappedObjects.containerMaps Container maps. * @property {number} mappedObjects.tilemapMaps Tilemap maps. * @property {number} mappedObjects.matterMaps Matter body maps. */ this._stats = { mappedObjects: { total: 0, static: 0, dynamic: 0, rectangleMaps: 0, polygonMaps: 0, circleMaps: 0, lineMaps: 0, containerMaps: 0, tilemapMaps: 0, matterMaps: 0 } }; /** * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds. * If world size will change after creation of Raycaster, bounding box needs to be updated. * * @name Raycaster#boundingBox * @type {Phaser.Geom.Rectangle} * @default false * @private * @since 0.6.0 */ this.boundingBox = false; /** * Array of mapped game objects. * * @name Raycaster#mappedObjects * @type {object[]} * @since 0.6.0 */ this.mappedObjects = []; /** * Array of dynamic mapped game objects. * * @name Raycaster#dynamicMappedObjects * @type {object[]} * @since 0.10.6 */ this.dynamicMappedObjects = []; /** * Number of segments of circle maps. * * @name Raycaster#mapSegmentCount * @type {number} * @default 0 * @since 0.6.0 */ this.mapSegmentCount = 0; if(options !== undefined) { if(options.boundingBox === undefined &amp;&amp; options.scene !== undefined) { if(options.scene.physics !== undefined) options.boundingBox = options.scene.physics.world.bounds; else if(options.scene.matter !== undefined) { let walls = options.scene.matter.world.walls; if(walls.top !== null) { options.boundingBox = new Phaser.Geom.Rectangle( walls.top.vertices[3].x, walls.top.vertices[3].y, walls.bottom.vertices[1].x - walls.top.vertices[3].x, walls.bottom.vertices[1].y - walls.top.vertices[3].y ); } } } this.setOptions(options); if(options.autoUpdate === undefined || options.autoUpdate) //automatically update event this.scene.events.on('update', this.update, this); } else //automatically update event this.scene.events.on('update', this.update, this); return this; } Raycaster.prototype = { /** * Configure raycaster. * * @method Raycaster#setOptions * @memberof Raycaster * @instance * @since 0.6.0 * * @param {object} [options] - Raycaster's congfiguration options. May include: * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used. * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. * @param {(object|object[])} [options.objects] - Game object or array of game objects to map. * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ setOptions: function(options) { if(options.scene !== undefined) { this.scene = options.scene; this.graphics = this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } }); this.graphics.setDepth(999); } if(options.debug !== undefined &amp;&amp; options.debug !== false) { this.debugOptions.enabled = true; if(typeof options.debug === 'object') Object.assign(this.debugOptions, options.debug); } if(options.mapSegmentCount !== undefined) this.mapSegmentCount = options.mapSegmentCount; if(options.objects !== undefined) this.mapGameObjects(options.objects); if(options.boundingBox !== undefined) this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height) return this; }, /** * Set Raycaster's bounding box. * * @method Raycaster#setBoundingBox * @memberof Raycaster * @instance * @since 0.6.0 * * @param {number} x - The X coordinate of the top left corner of bounding box. * @param {number} y - The Y coordinate of the top left corner of bounding box. * @param {number} width - The width of bounding box. * @param {number} height - The height of bounding box. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ setBoundingBox: function(x, y, width, height) { this.boundingBox = { rectangle: new Phaser.Geom.Rectangle(x, y, width, height), points: [], segments: [] } //set points let points = [ new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top), new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom), new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom) ]; this.boundingBox.points = points; //set segments for(let i = 0, length = this.boundingBox.points.length; i &lt; length; i++) { if(i+1 &lt; length) this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y)); else this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y)); } }, /** * Map game objects * * @method Raycaster#mapGameObjects * @memberof Raycaster * @instance * @since 0.6.0 * * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map. * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically). * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map} * * @return {Raycaster} {@link Raycaster Raycaster} instance */ mapGameObjects: function(objects, dynamic = false, options = {}) { options.dynamic = dynamic; options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount; if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { if(this.mappedObjects.includes(object)) continue; //if object is not supported if(object.data &amp;&amp; object.data.get('raycasterMapNotSupported')) continue; let config = {}; for(let option in options) { config[option] = options[option]; } config.object = object; let map = new this.Map(config, this); if(map.notSupported) { map.destroy(); continue; } if(object.type === 'body' || object.type === 'composite') { object.raycasterMap = map; } else if(!object.data) { object.setDataEnabled(); object.data.set('raycasterMap', map); } else { object.data.set('raycasterMap', map); } this.mappedObjects.push(object); //update stats switch(object.type) { case 'Polygon': this._stats.mappedObjects.polygonMaps++; break; case 'Arc': this._stats.mappedObjects.circleMaps++; break; case 'Line': this._stats.mappedObjects.lineMaps++; break; case 'Container': this._stats.mappedObjects.containerMaps++; break; case 'StaticTilemapLayer': this._stats.mappedObjects.tilemapMaps++; break; case 'DynamicTilemapLayer': this._stats.mappedObjects.tilemapMaps++; break; case 'TilemapLayer': this._stats.mappedObjects.tilemapMaps++; break; case 'MatterBody': this._stats.mappedObjects.matterMaps++; break; default: this._stats.mappedObjects.rectangleMaps++; } } this._stats.mappedObjects.total = this.mappedObjects.length; this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length; return this; }, /** * Remove game object's {@link Raycaster.Map Raycaster.Map} maps. * * @method Raycaster#removeMappedObjects * @memberof Raycaster * @instance * @since 0.6.0 * * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ removeMappedObjects: function(objects) { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { //remove object from mapped objects list let index = this.mappedObjects.indexOf(object); if(index === -1) { continue; } this.mappedObjects.splice(index, 1); //remove object from dynamic mapped objects list index = this.dynamicMappedObjects.indexOf(object); if(index &gt;= 0) this.dynamicMappedObjects.splice(index, 1); if(object.type === 'body' || object.type === 'composite') { object.raycasterMap.destroy(); } else { object.data.get('raycasterMap').destroy(); } //update stats switch(object.type) { case 'Polygon': this._stats.mappedObjects.polygonMaps--; break; case 'Arc': this._stats.mappedObjects.circleMaps--; break; case 'Line': this._stats.mappedObjects.lineMaps--; break; case 'Container': this._stats.mappedObjects.containerMaps--; break; case 'StaticTilemapLayer': this._stats.mappedObjects.tilemapMaps--; break; case 'DynamicTilemapLayer': this._stats.mappedObjects.tilemapMaps--; break; case 'TilemapLayer': this._stats.mappedObjects.tilemapMaps--; break; case 'MatterBody': this._stats.mappedObjects.matterMaps--; break; default: this._stats.mappedObjects.rectangleMaps--; } } this._stats.mappedObjects.total = this.mappedObjects.length; this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length; this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length; return this; }, /** * Enable game object's {@link Raycaster.Map Raycaster.Map} maps. * * @method Raycaster#enableMaps * @memberof Raycaster * @instance * @since 0.7.2 * * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ enableMaps: function(objects) { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { let map; if(object.type === 'body' || object.type === 'composite') { map = object.raycasterMap; } else if(object.data) { map = object.data.get('raycasterMap'); } if(map) map.active = true; } return this; }, /** * Disable game object's {@link Raycaster.Map Raycaster.Map} maps. * * @method Raycaster#disableMaps * @memberof Raycaster * @instance * @since 0.7.2 * * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled. * * @return {Raycaster} {@link Raycaster Raycaster} instance */ disableMaps: function(objects) { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { let map; if(object.type === 'body' || object.type === 'composite') { map = object.raycasterMap; } else if(object.data) { map = object.data.get('raycasterMap'); } if(map) map.active = false; } return this; }, /** * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event. * * @method Raycaster#update * @memberof Raycaster * @instance * @since 0.6.0 * * @return {Raycaster} {@link Raycaster Raycaster} instance */ update: function() { //update dynamic maps if(this.dynamicMappedObjects.length &gt; 0) { for(let mapppedObject of this.dynamicMappedObjects) { let map; if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') { map = mapppedObject.raycasterMap; } else if(mapppedObject.data) { map = mapppedObject.data.get('raycasterMap'); } if(!map) continue; if(map.active) { map.updateMap(); } } } //debug if(this.debugOptions.enabled) this.drawDebug(); return this; }, /** * Create {@link Raycaster.Ray Raycaster.Ray} object. * * @method Raycaster#createRay * @memberof Raycaster * @instance * @since 0.6.0 * * @param {object} [options] - Ray's congfiguration options. May include: * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position. * @param {number} [options.angle = 0] - Ray's angle in radians. * @param {number} [options.angleDeg = 0] - Ray's angle in degrees. * @param {number} [options.cone = 0] - Ray's cone angle in radians. * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees. * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view. * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes. * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}. * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded. * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ createRay: function(options = {}) { return new this.Ray(options, this); }, /** * Get raycaster statistics. * * @method Raycaster#getStats * @memberof Raycaster * @instance * @since 0.10.0 * * @return {object} Raycaster statistics. */ getStats: function() { return this._stats; }, /** * Draw maps in debug mode * * @method Raycaster#drawDebug * @memberof Raycaster * @private * @since 0.10.0 * * @return {Raycaster} {@link Raycaster Raycaster} instance */ drawDebug: function() { if(this.graphics === undefined || !this.debugOptions.enabled) return this; //clear this.graphics.clear(); if(!this.debugOptions.maps) return this; for(let object of this.mappedObjects) { let map; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else if(object.data) map = object.data.get('raycasterMap'); if(!map) continue; //draw bounding box if(this.debugOptions.graphics.mapBoundingBox) { this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox); this.graphics.strokeRectShape(map.getBoundingBox()); } //draw segments if(this.debugOptions.graphics.mapSegment) { this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment); for(let segment of map.getSegments()) { this.graphics.strokeLineShape(segment); } } //draw points if(this.debugOptions.graphics.mapPoint) { this.graphics.fillStyle(this.debugOptions.graphics.mapPoint); for(let point of map.getPoints()) { this.graphics.fillPoint(point.x, point.y, 3) } } } return this; }, /** * Destroy object and all mapped objects. * * @method Raycaster#destroy * @memberof Raycaster * @instance * @since 0.10.3 */ destroy: function() { this.removeMappedObjects(this.mappedObjects); if(this.graphics) this.graphics.destroy(); if(this.scene) { this.scene.events.removeListener('update', null, this); } for(let key in this) { delete this[key]; } } } Raycaster.prototype.Map = require('./map/map-core.js').Map; Raycaster.prototype.Ray = require('./ray/ray-core.js').Ray; × Search results Close Phaser-raycaster "},"ray_ray-core.js.html":{"id":"ray_ray-core.js.html","title":"Source: ray/ray-core.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/ray-core.js /** * @classdesc * * Ray class responsible for casting ray's and testing their collisions with mapped objects. * * @namespace Raycaster.Ray * @class Raycaster.Ray * @constructor * @since 0.6.0 * * @param {object} [options] - Ray's congfiguration options. May include: * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position. * @param {number} [options.angle = 0] - Ray's angle in radians. * @param {number} [options.angleDeg = 0] - Ray's angle in degrees. * @param {number} [options.cone = 0] - Ray's cone angle in radians. * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees. * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view. * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes. * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}. * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded. * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added. * @param {Raycaster} [raycaster] - Parent raycaster object. */ export function Ray(options, raycaster) { /** * Reference to parent Raycaster object. * * @name Raycaster.Ray#_raycaster * @type {Raycaster} * @private * @since 0.6.0 */ this._raycaster = raycaster ? raycaster : false; /** * Ray's source position. * * @name Raycaster.Ray#origin * @type {Phaser.Geom.Point} * @since 0.6.0 */ this.origin = new Phaser.Geom.Point(); /** * Ray's representation used to calculating intersections. * * @name Raycaster.Ray#_ray * @type {Phaser.Geom.Line} * @private * @since 0.6.0 */ this._ray = new Phaser.Geom.Line(); /** * Ray's angle in radians. * * @name Raycaster.Ray#angle * @type {number} * @default 0 * @since 0.6.0 */ this.angle = 0; /** * Ray's cone width angle in radians. * * @name Raycaster.Ray#cone * @type {number} * @default 0 * @since 0.7.0 */ this.cone = 0; /** * Ray's maximum range * * @name Raycaster.Ray#rayRange * @type {number} * @default Phaser.Math.MAX_SAFE_INTEGER * @since 0.6.0 */ this.rayRange = Phaser.Math.MAX_SAFE_INTEGER; /** * Ray's maximum detection range. Objects outside detection range won't be tested. * Ray tests all objects when set to 0. * * @name Raycaster.Ray#detectionRange * @type {number} * @default * @since 0.6.0 */ this.detectionRange = 0; /** * Ray's representation of detection range used in calculating if objects are in range. * * @name Raycaster.Ray#detectionRangeCircle * @type {Phaser.Geom.Circle} * @private * @since 0.6.0 */ this.detectionRangeCircle = new Phaser.Geom.Circle(); /** * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}. * * @name Raycaster.Ray#collisionRange * @type {number} * @default Phaser.Math.MAX_SAFE_INTEGER * @since 0.8.0 */ this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER; /** * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. * * @name Raycaster.Ray#ignoreNotIntersectedRays * @type {boolean} * @default true * @since 0.6.0 */ this.ignoreNotIntersectedRays = true; /** * If set true, ray's hit points will be rounded. * * @name Raycaster.Ray#round * @type {boolean} * @default false * @since 0.8.1 */ this.round = false; /** * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}. * * @name Raycaster.Ray#autoSlice * @type {boolean} * @default false * @since 0.8.0 */ this.autoSlice = false; /** * Array of intersections from last raycast representing field of view. * * @name Raycaster.Ray#intersections * @type {object[]} * @default [] * @since 0.8.0 */ this.intersections = []; /** * Array of triangles representing slices of field of view from last raycast. * * @name Raycaster.Ray#slicedIntersections * @type {Phaser.Geom.Triangle[]} * @default [] * @since 0.8.0 */ this.slicedIntersections = []; /** * Physics body for testing field of view collisions. * * @name Raycaster.Ray#body * @type {object} * @default undefined * @since 0.8.0 */ //this.body = false; /** * Physics body type. * * @name Raycaster.Ray#bodyType * @type {(boolean|'arcade'|'matter')} * @default false * @since 0.9.0 */ this.bodyType = false; /** * Ray casting stats. * * @name Raycaster.Ray#_stats * @type {object} * @private * @since 0.10.0 * * @property {string} method Used casting method (cast, castCircle, castCone). * @property {number} rays Casted rays. * @property {number} testedMappedObjects Tested mapped objects. * @property {number} hitMappedObjects Hit mapped objects. * @property {number} segments Tested segments. * @property {number} time Casting time. */ this._stats = { method: 'cast', rays: 0, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }; /** * Ray's graphics object used for debug * * @name Raycaster.Ray#graphics * @type {Phaser.GameObjects.Graphics} * @private * @since 0.10.0 */ this.graphics; this.config(options); }; Ray.prototype = { config: require('./config.js').config, getStats: require('./stats.js').getStats, setRay: require('./ray.js').setRay, setOrigin: require('./origin.js').setOrigin, setRayRange: require('./range.js').setRayRange, setAngle: require('./angle.js').setAngle, setAngleDeg: require('./angle.js').setAngleDeg, setCone: require('./cone.js').setCone, setConeDeg: require('./cone.js').setConeDeg, setDetectionRange: require('./range.js').setDetectionRange, boundsInRange: require('./range.js').boundsInRange, cast: require('./cast.js').cast, castCircle: require('./castCircle.js').castCircle, castCone: require('./castCone.js').castCone, slice: require('./slice.js').slice, setCollisionRange: require('./range.js').setCollisionRange, enablePhysics: require('./enablePhysics.js').enablePhysics, overlap: require('./overlap.js').overlap, processOverlap: require('./overlap.js').processOverlap, testArcadeOverlap: require('./overlap.js').testArcadeOverlap, testMatterOverlap: require('./overlap.js').testMatterOverlap, setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory, setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup, setCollidesWith: require('./matter-physics-methods.js').setCollidesWith, setOnCollide: require('./matter-physics-methods.js').setOnCollide, setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd, setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive, setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith, drawDebug: require('./debug.js').drawDebug, destroy: require('./destroy.js').destroy, }; × Search results Close Phaser-raycaster "},"ray_config.js.html":{"id":"ray_config.js.html","title":"Source: ray/config.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/config.js /** * Configure ray. * * @method Raycaster.Ray#config * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} [options] - Ray's congfiguration options. May include: * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position. * @param {number} [options.angle = 0] - Ray's angle in radians. * @param {number} [options.angleDeg = 0] - Ray's angle in degrees. * @param {number} [options.cone = 0] - Ray's cone angle in radians. * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees. * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view. * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes. * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}. * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded. * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function config(options) { this.object = options.object; //origin if(options.origin !== undefined) this.origin.setTo(options.origin.x, options.origin.y); //angle if(options.angle !== undefined) this.angle = Phaser.Math.Angle.Normalize(options.angle); //angle deg if(options.angleDeg !== undefined) this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg)); //cone angle if(options.cone !== undefined) this.cone = options.cone; //cone angle deg if(options.coneDeg !== undefined) this.cone = Phaser.Math.DegToRad(options.coneDeg); //ray range (0 = max) if(options.rayRange !== undefined) this.rayRange = options.rayRange; //collision range (0 = max) if(options.collisionRange !== undefined) this.collisionRange = options.collisionRange; //detection range (0 = max) if(options.detectionRange !== undefined) this.detectionRange = options.detectionRange; //ignore not intersected rays if(options.ignoreNotIntersectedRays !== undefined) this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true) //round if(options.round !== undefined) this.round = (options.round == true) //auto slice if(options.autoSlice !== undefined) this.autoSlice = (options.autoSlice == true) //enable physics if(options.enablePhysics !== undefined &amp;&amp; options.enablePhysics) this.enablePhysics(options.enablePhysics); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange); if(this._raycaster.debugOptions.enabled &amp;&amp; this._raycaster.scene !== undefined) { this.graphics = this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } }); this.graphics.setDepth(1000); } return this; } × Search results Close Phaser-raycaster "},"ray_cast.js.html":{"id":"ray_cast.js.html","title":"Source: ray/cast.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/cast.js /** * Cast ray to find closest intersection with tested mapped objects. * * @method Raycaster.Ray#cast * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} [options] - options that may include: * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects. * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point. * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method. * * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available. */ export function cast(options = {}) { let closestIntersection; let closestSegment; let closestObject; let closestDistance = this.rayRange; let internal = options.internal ? options.internal : false; let startTime = performance.now(); let stats = { method: 'cast', rays: 1, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }; //if bounding box is defined check bounding box intersection if(this._raycaster &amp;&amp; this._raycaster.boundingBox) { let intersections = []; Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections); if(intersections.length === 1) closestIntersection = intersections[0]; else if(intersections.length &gt; 1) { for(let intersection of intersections) { let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; } } } //if ray target is declared else if(options.target){ let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y); //if target is within ray range if(this.rayRange &gt; distance) { closestDistance = distance; closestIntersection = options.target; } } } //if no objects to cast ray were passed, use raycasters mapped objects if(!options.objects) { if(this._raycaster) options.objects = this._raycaster.mappedObjects; else return intersections; } for(let object of options.objects) { let map, boundingBox, boundingBoxIntersections = [], canTestMap = false; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else map = object.data.get('raycasterMap'); stats.testedMappedObjects++; //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1) if(internal) { boundingBox = map._boundingBox; } else { boundingBox = map.getBoundingBox(); boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2); } //check if object is intersected by ray if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0) continue; //check if bounding box is closer than closest intersection if(Phaser.Geom.Rectangle.ContainsPoint(boundingBox, this.origin)) { canTestMap = true; } else { for(let boundingBoxIntersection of boundingBoxIntersections) { if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) &lt; closestDistance) { canTestMap = true; break; } } } if(!canTestMap) continue; stats.hitMappedObjects++; stats.segments += map.getSegments(this).length; //check intersections for(let segment of map.getSegments(this)) { let intersection = []; //if target point is segmemt point if(options.target) { if( Phaser.Geom.Point.Equals(options.target, segment.getPointA()) || Phaser.Geom.Point.Equals(options.target, segment.getPointB()) ) { intersection = options.target; } else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection)) continue; } //if no intersection continue else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection)) continue; //get closest intersection let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; closestObject = map.object; closestSegment = segment; } } //check if map is circular if(map.circle) { //if circular map has generated points (besides tangent points to ray) if(map._points.length &gt; 0) { continue; } //check if target point is a circle tangent point to ray if(options.target) { let points = map.getPoints(this); let isTangent = false; for(let point of points) { if(Phaser.Geom.Point.Equals(options.target, point)) { //get closest intersection let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = point; closestObject = map.object; isTangent = true; break; } } } if(isTangent) continue; } let circleIntersections = []; let offset = new Phaser.Geom.Point(); offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5); offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5); //calculate circle's center after rotation let rotation = map.object.rotation; if(rotation !== 0) { let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y); Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector)); let cB = vector.getPointB(); offset.x = cB.x; offset.y = cB.y; } //create transformed circle let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX); if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) { for(let intersection of circleIntersections) { //get closest intersection let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; closestObject = map.object; } } } } //check container map's circles if(map.type == 'Container' &amp;&amp; map._circles.length &gt; 0) { for(let circle of map._circles) { //check if target point is a circle tangent point to ray if(options.target) { let isTangent = false; for(let point of circle.points) { if(Phaser.Geom.Point.Equals(options.target, point)) { //get closest intersection let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = point; closestObject = map.object; isTangent = true; break; } } } if(isTangent) continue; } let circleIntersections = []; if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) { for(let intersection of circleIntersections) { //get closest intersection let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y); if(distance &lt; closestDistance) { closestDistance = distance; closestIntersection = intersection; closestObject = map.object; } } } } } } //update stats if(internal) { this._stats.rays++; this._stats.testedMappedObjects += stats.testedMappedObjects; this._stats.hitMappedObjects += stats.hitMappedObjects; this._stats.segments += stats.segments; } else { stats.time = performance.now() - startTime; this._stats = stats; } let result; if(!closestIntersection) { if(this.ignoreNotIntersectedRays) return false; result = this._ray.getPointB(); } else { result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y); result.segment = closestSegment; result.object = closestObject; } if(this.round) { result.x = Math.round(result.x); result.y = Math.round(result.y); } if(!internal) this.drawDebug([result]); return result; } × Search results Close Phaser-raycaster "},"ray_castCircle.js.html":{"id":"ray_castCircle.js.html","title":"Source: ray/castCircle.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/castCircle.js /** * Cast ray in all directions to find closest intersections with tested mapped objects. * * @method Raycaster.Ray#castCircle * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} [options] - options that may include: * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects. * * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available. */ export function castCircle(options = {}) { let originalAngle = this.angle; let intersections = []; let maps = []; let rayTargets = []; let testedObjects = []; let startTime = performance.now(); //reset stats this._stats = { method: 'castCircle', rays: 0, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }; //if no objects to cast ray were passed, use raycasters mapped objects if(!options.objects) { if(this._raycaster) options.objects = this._raycaster.mappedObjects; else return intersections; } //if bounding box is defined add bounding box points to if(this._raycaster &amp;&amp; this._raycaster.boundingBox) { for(let point of this._raycaster.boundingBox.points) { rayTargets.push({ point: point, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y) }); } } for(let i=0, iLength = options.objects.length; i &lt; iLength; i++) { let object = options.objects[i]; //if bound in range if(!this.boundsInRange(object)) continue; testedObjects.push(object); let map, boundingBox; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else map = object.data.get('raycasterMap'); //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1) boundingBox = map.getBoundingBox(); boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2); map._boundingBox = boundingBox; maps.push(map); //get points and angles for(let point of map.getPoints(this)) { rayTargets.push({ point: point, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y) }); } //get objects intersections for(let j = i+1, jLength = options.objects.length; j &lt; jLength; j++){ let objectB = options.objects[j]; let mapB; if(objectB.type === 'body' || objectB.type === 'composite') mapB = objectB.raycasterMap; else { mapB = objectB.data.get('raycasterMap'); } //check if bounding boxes overlap if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox())) continue; //find objects intersections for(let segmentA of map.getSegments(this)) { for(let segmentB of mapB.getSegments(this)) { let intersection = []; if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection)) continue; let target = { point: new Phaser.Geom.Point(intersection.x, intersection.y), angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y) }; target.point.intersection = false; rayTargets.push(target); } } } } //sort target points by angle rayTargets.sort(function(a, b){ //if rays towards points have the same angles promote closer one if(a.angle == b.angle) { if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) &gt; Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y)) return 1; else return -1; } return a.angle - b.angle; }.bind(this)); let previousTarget = { angle: false }; //cast rays for(let target of rayTargets){ //if current target is the same as previous one skip loop if(target.angle === previousTarget.angle) { continue; } previousTarget = target; this.setAngle(target.angle); let intersection = this.cast({ objects: testedObjects, target: target.point, internal: true }); if(intersection) { //if intersection hits target point check if ray \"glanced\" mapped object. let castSides = false; if(this.round) { let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y)); castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection) } else { castSides = Phaser.Geom.Point.Equals(target.point, intersection); } if(!castSides) { //castSides = false; } else if(!target.point.neighbours || target.point.neighbours.length &lt; 2) { //castSides = true; } //check if ray and at least one line between target point and it's neighbours are parallel else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) &lt; 0.0001 || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) &lt; 0.0001) { //castSides = true; } //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours else { let triangleIntersections = []; if(!target.point.neighboursTriangle) { target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y); } Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections); //if point of intersection of ray and tirangle are close to target point, assume ray \"glanced\" triangle. for(let triangleIntersection of triangleIntersections) { if(Math.abs(target.point.x - triangleIntersection.x) &gt; 0.0001 &amp;&amp; Math.abs(target.point.y - triangleIntersection.y) &gt; 0.0001) { castSides = false; break; } } } //if ray \"glanced\" mapped object cast two additional rays if(castSides) { this.setAngle(target.angle - 0.0001); let intersectionA = this.cast({ objects: testedObjects, internal: true }); if(intersectionA) { intersections.push(intersectionA); } intersections.push(intersection); this.setAngle(target.angle + 0.0001); let intersectionB = this.cast({ objects: testedObjects, internal: true }); if(intersectionB) { intersections.push(intersectionB); } continue; } intersections.push(intersection); } } this.setAngle(originalAngle); this.intersections = intersections; if(this.autoSlice) this.slicedIntersections = this.slice(); this._stats.time = performance.now() - startTime; this.drawDebug(intersections); return intersections; } × Search results Close Phaser-raycaster "},"ray_castCone.js.html":{"id":"ray_castCone.js.html","title":"Source: ray/castCone.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/castCone.js /** * Cast ray in a cone to find closest intersections with tested mapped objects. * * @method Raycaster.Ray#castCone * @memberof Raycaster.Ray * @instance * @since 0.7.0 * * @param {object} [options] - options that may include: * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects. * * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available. */ export function castCone(options = {}) { let originalAngle = this.angle; let intersections = []; let maps = []; let rayTargets = []; let testedObjects = []; let cone = this.cone; let minAngle = 0; let maxAngle = 0; let angleOffset = 0; let startTime = performance.now(); //reset stats this._stats = { method: 'castCone', rays: 0, testedMappedObjects: 0, hitMappedObjects: 0, segments: 0, time: 0 }; //set cone if(options.cone !== undefined) cone = options.cone; if(options.coneDeg !== undefined) cone = Phaser.Math.DegToRad(options.coneDeg); //set cone min and max angle minAngle = this.angle - cone / 2; maxAngle = this.angle + cone / 2; //add min and max angle points this.setAngle(minAngle); rayTargets.push({ point: this._ray.getPointB(), angle: minAngle, angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2) }); this.setAngle(maxAngle); rayTargets.push({ point: this._ray.getPointB(), angle: maxAngle, angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2) }); //if no objects to cast ray were passed, use raycasters mapped objects if(!options.objects) { if(this._raycaster) options.objects = this._raycaster.mappedObjects; else return intersections; } //if bounding box is defined add bounding box points to if(this._raycaster &amp;&amp; this._raycaster.boundingBox) { for(let point of this._raycaster.boundingBox.points) { let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y); let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle)); if(Math.abs(angleOffsetDeg) &lt; Phaser.Math.RadToDeg(cone / 2)) { rayTargets.push({ point: point, angle: angle, angleOffsetDeg: -angleOffsetDeg }); } } } for(let i=0, iLength = options.objects.length; i &lt; iLength; i++) { let object = options.objects[i]; //if bound in range if(!this.boundsInRange(object)) continue; testedObjects.push(object); let map, boundingBox; if(object.type === 'body' || object.type === 'composite') map = object.raycasterMap; else map = object.data.get('raycasterMap'); //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1) boundingBox = map.getBoundingBox(); boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2); map._boundingBox = boundingBox; maps.push(map); //get points and angles for(let point of map.getPoints(this)) { let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y); let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle)); if(Math.abs(angleOffsetDeg) &lt; Phaser.Math.RadToDeg(cone / 2)) { rayTargets.push({ point: point, angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y), angleOffsetDeg: -angleOffsetDeg }); } } //get objects intersections for(let j = i+1, jLength = options.objects.length; j &lt; jLength; j++){ let objectB = options.objects[j]; let mapB; if(objectB.type === 'body' || objectB.type === 'composite') mapB = objectB.raycasterMap; else mapB = objectB.data.get('raycasterMap'); //check if bounding boxes overlap if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox())) continue; //find objects intersections for(let segmentA of map.getSegments(this)) { for(let segmentB of mapB.getSegments(this)) { let intersection = []; if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection)) continue; let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y); let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle)); if(Math.abs(angleOffsetDeg) &lt; Phaser.Math.RadToDeg(cone / 2)) { rayTargets.push({ point: new Phaser.Geom.Point(intersection.x, intersection.y), angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y), angleOffsetDeg: -angleOffsetDeg }); } } } } } //sort target points by angle rayTargets.sort(function(a, b){ //if rays towards points have the same angles promote closer one if(a.angle == b.angle) { if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) &gt; Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y)) return 1; else return -1; } return a.angleOffsetDeg - b.angleOffsetDeg; }.bind(this)); let previousTarget = { angle: false }; //cast rays for(let target of rayTargets){ //if current target is the same as previous one skip loop if(target.angle === previousTarget.angle) { continue; } previousTarget = target; this.setAngle(target.angle); let intersection = this.cast({ objects: testedObjects, target: target.point, internal: true }); if(intersection) { //if intersection hits target point check if ray \"glanced\" mapped object. let castSides = false; if(this.round) { let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y)); castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection) } else { castSides = Phaser.Geom.Point.Equals(target.point, intersection); } if(!castSides) { //castSides = false; } else if(!target.point.neighbours || target.point.neighbours.length &lt; 2) { //castSides = true; } //check if ray and at least one line between target point and it's neighbours are parallel else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) &lt; 0.0001 || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) &lt; 0.0001) { //castSides = true; } //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours else { let triangleIntersections = []; if(!target.point.neighboursTriangle) { target.point.neighboursTriangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y); } Phaser.Geom.Intersects.GetTriangleToLine(target.point.neighboursTriangle, this._ray, triangleIntersections); //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle. for(let triangleIntersection of triangleIntersections) { if(Math.abs(target.point.x - triangleIntersection.x) &gt; 0.0001 &amp;&amp; Math.abs(target.point.y - triangleIntersection.y) &gt; 0.0001) { castSides = false; break; } } } //if ray \"glanced\" mapped object cast two additional rays if(castSides) { this.setAngle(target.angle - 0.0001); let intersectionA = this.cast({ objects: testedObjects, internal: true }); if(intersectionA) { intersections.push(intersectionA); } intersections.push(intersection); this.setAngle(target.angle + 0.0001); let intersectionB = this.cast({ objects: testedObjects, internal: true }); if(intersectionB) { intersections.push(intersectionB); } continue; } intersections.push(intersection); } } this.setAngle(originalAngle); this.intersections = intersections; if(this.autoSlice) this.slicedIntersections = this.slice(intersections, false); this._stats.time = performance.now() - startTime; this.drawDebug(intersections); return intersections; } × Search results Close Phaser-raycaster "},"ray_ray.js.html":{"id":"ray_ray.js.html","title":"Source: ray/ray.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/ray.js /** * Set ray's position, direction (angle) and range. * * @method Raycaster.Ray#setRay * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {number} x - X coordinate. * @param {number} y - Y coordinate. * @param {number} [angle] - Ray's angle in radians. * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) { this.origin.setTo(x, y); this.angle = Phaser.Math.Angle.Normalize(angle); this.rayRange = rayRange; Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange); return this; } × Search results Close Phaser-raycaster "},"ray_origin.js.html":{"id":"ray_origin.js.html","title":"Source: ray/origin.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/origin.js /** * Set ray's source position. * * @method Raycaster.Ray#setOrigin * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {number} x - X coordinate. * @param {number} y - Y coordinate. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setOrigin(x, y) { this.origin.setTo(x, y); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange); if(this.bodyType === 'matter' &amp;&amp; this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) { this.collisionCircle.x = x; this.collisionCircle.y = y; } else if(this.bodyType === 'arcade') { this.collisionCircle.x = x; this.collisionCircle.y = y; } return this; } × Search results Close Phaser-raycaster "},"ray_angle.js.html":{"id":"ray_angle.js.html","title":"Source: ray/angle.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/angle.js /** * Set ray's angle (direction) in radians. * * @method Raycaster.Ray#setAngle * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {number} [angle = 0] - Ray's angle in radians. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setAngle(angle = 0) { this.angle = Phaser.Math.Angle.Normalize(angle); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); return this; } /** * Set ray's angle (direction) in degrees. * * @method Raycaster.Ray#setAngleDeg * @memberof Raycaster.Ray * @instance * @since 0.6.1 * * @param {number} [angle = 0] - Ray's angle in degrees. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setAngleDeg(angle = 0) { this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle)); Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); return this; } × Search results Close Phaser-raycaster "},"ray_range.js.html":{"id":"ray_range.js.html","title":"Source: ray/range.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/range.js /** * Set ray's range. * * @method Raycaster.Ray#setRayRange * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) { this.rayRange = rayRange; Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange); return this; } /** * Set ray's maximum detection range. Objects outside detection range won't be tested. * Ray tests all objects when set to 0. * * @method Raycaster.Ray#setDetectionRange * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setDetectionRange(detectionRange = 0) { this.detectionRange = detectionRange; this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange); return this; } /** * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method. * Determines ray's physics body radius. * * @method Raycaster.Ray#setCollisionRange * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) { let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER; this.collisionRange = collisionRange; this.collisionCircle.setRadius(this.collisionRange); if(this.bodyType === 'matter') { if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) { let bounds = this._raycaster.boundingBox; this._raycaster.scene.matter.body.set(this.body, { shape: { type: 'rectangle', x: bounds.rectangle.centerX, y: bounds.rectangle.centerY, width: bounds.rectangle.width, height: bounds.rectangle.height, circleRadius:0 } }); } else if(oldRangeMax) { this._raycaster.scene.matter.body.set(this.body, { shape: { type: 'circle', x: this.collisionCircle.x, y: this.collisionCircle.y }, circleRadius: this.collisionRange, isStatic: false }); } else { this.collisionCircle.setRadius(this.collisionRange); } this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange) } else if(this.bodyType === 'arcade') { this.body.setCircle(this.collisionRange); } return this; } /** * Test if object's bounding box is in ray's detection range. * * @method Raycaster.Ray#boundsInRange * @memberof Raycaster.Ray * @instance * @since 0.6.0 * * @param {object} object - Tested object * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically. * * @return {boolean} Information if object is in ray's detection range. */ export function boundsInRange(object, bounds = false) { if(!this.detectionRange) return true; let objectBounds; if(bounds) objectBounds = bounds; else { if(object.type === 'body' || object.type === 'composite') objectBounds = object.raycasterMap.getBoundingBox(); else objectBounds = object.data.get('raycasterMap').getBoundingBox(); } if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds)) return true; return false; } × Search results Close Phaser-raycaster "},"ray_cone.js.html":{"id":"ray_cone.js.html","title":"Source: ray/cone.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/cone.js /** * Set ray's cone angle (width) in radians. * * @method Raycaster.Ray#setCone * @memberof Raycaster.Ray * @instance * @since 0.7.0 * * @param {number} [cone = 0] - Ray's cone angle in radians. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCone(cone = 0) { this.cone = cone; return this; } /** * Set ray's cone angle (width) in degrees. * * @method Raycaster.Ray#setConeDeg * @memberof Raycaster.Ray * @instance * @since 0.7.0 * * @param {number} [cone = 0] - Ray's cone angle in degrees. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setConeDeg(cone = 0) { this.cone = Phaser.Math.DegToRad(cone); return this; } × Search results Close Phaser-raycaster "},"ray_overlap.js.html":{"id":"ray_overlap.js.html","title":"Source: ray/overlap.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/overlap.js /** * Get game objects overlaping field of view. * * @method Raycaster.Ray#overlap * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {object|object[]} [objects] - Game object / array off game objects to test. * * @return {object[]} Array of game objects that overlaps with field of view. */ export function overlap(objects) { let targets = []; let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange); //matter physics if(this.bodyType === 'matter') { let isCollisionInfo = false; if(objects === undefined) { objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies()); for(let object of objects) { let body = object.bodyA === this.body ? object.bodyB : object.bodyA; if(this.testMatterOverlap(body)) targets.push(body); } } //get object's body else { if(!Array.isArray(objects)) objects = [objects]; for(let object of objects) { if(object === this.body) continue; if(this.testMatterOverlap(object)) targets.push(object); } } } //arcade physics else { let bodies = false; //get bodies in range if(objects === undefined) { objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true); bodies = true; } //get object's body else if(!Array.isArray(objects)) { objects = [objects]; } //if objects are bodies if(bodies) { for(let body of objects) { if(body === this.body) continue; let hitbox; //get physics body hitbox if(body.isCircle) { hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth); } else { hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height); } if(this.testArcadeOverlap(hitbox)) targets.push(body.gameObject); } } //if objects are game objects else { for(let object of objects) { if(object.body === undefined) continue; let hitbox; //get physics body hitbox if(object.body.isCircle) { hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth); if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox)) continue; } else { hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height); if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox)) continue; } if(this.testArcadeOverlap(hitbox)) targets.push(object); } } } return targets; } /** * Process callback for physics collider / overlap. * * @method Raycaster.Ray#processOverlap * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object. * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument. * * @return {boolean} Return true if game object is overlapping ray's field of view. */ export function processOverlap(object1, object2) { let obj1, obj2, target; //check if it's matter collisionInfo object if(object1.bodyA !== undefined &amp;&amp; object1.bodyB !== undefined) { obj1 = object1.bodyA; obj2 = object1.bodyB; } else { obj1 = object1; obj2 = object2; } if(obj1._ray !== undefined &amp;&amp; obj1._ray === this) target = obj2; else if(obj2._ray !== undefined &amp;&amp; obj2._ray === this) target = obj1; else return false; return (this.overlap(target).length &gt; 0); } /** * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}. * * @method Raycaster.Ray#testArcadeOverlap * @memberof Raycaster.Ray * @instance * @private * @since 0.8.0 * * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}. * * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view. */ export function testArcadeOverlap(hitbox) { let overlap = false; //iterate through field of view slices to check collisions with target for(let slice of this.slicedIntersections) { //if hitbox is a circle if(hitbox.type == 0) { overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox); } //if hitbox is a rectangle else { overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice); } if(overlap) { return true; } } return false; } /** * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}. * * @method Raycaster.Ray#testMatterOverlap * @memberof Raycaster.Ray * @instance * @private * @since 0.9.0 * * @param {object} body - Matter body. * * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view. */ export function testMatterOverlap(object) { let body; if(object.type === 'body') body = object; else if(object.body !== undefined) body = object.body; else return false; //if body is concave, ignore convex body let parts = body.parts.length &gt; 1 ? body.parts.splice(1) : body.parts; //iterate through bodies for(let part of parts) { let pointA = part.vertices[0]; for(let i = 1, length = part.vertices.length; i &lt; length; i++) { let pointB = part.vertices[i]; let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y); //iterate through field of view slices to check collisions with target for(let slice of this.slicedIntersections) { let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment); //additional checking if slice contain segment's points due to TriangleToLine bug. if(!overlap) overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA()); if(!overlap) overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB()); if(overlap) { return true; } } pointA = pointB; } //closing segment let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y); //iterate through field of view slices to check collisions with target for(let slice of this.slicedIntersections) { let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment); if(overlap) { return true; } } } return false; } × Search results Close Phaser-raycaster "},"ray_enablePhysics.js.html":{"id":"ray_enablePhysics.js.html","title":"Source: ray/enablePhysics.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/enablePhysics.js /** * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once. * * @method Raycaster.Ray#enablePhysics * @memberof Raycaster.Ray * @instance * @since 0.8.0 * * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function enablePhysics(type = 'arcade') { if(this.body !== undefined) return this; this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange); this.collisionCircle._ray = this; if(type === 'matter') { this.bodyType = 'matter'; if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) { let bounds = this._raycaster.boundingBox; this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true }); } else { this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true }); } this.body = this.collisionCircle.body; this.body._ray = this; this.setOnCollideActive(); } else { this.bodyType = 'arcade'; this._raycaster.scene.physics.add.existing(this.collisionCircle); this.body = this.collisionCircle.body; this.body .setCircle(this.collisionRange) .setAllowGravity(false) .setImmovable(true); this.body._ray = this; } return this; } × Search results Close Phaser-raycaster "},"ray_matter-physics-methods.js.html":{"id":"ray_matter-physics-methods.js.html","title":"Source: ray/matter-physics-methods.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: ray/matter-physics-methods.js /*Matter physics methods for ray body*/ /** * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31. * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision * categories are included in their collision masks (see {@link #setCollidesWith}). * * @method Raycaster.Ray#setCollisionCategory * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {number} value - Unique category bitfield. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCollisionCategory(value) { this.body.collisionFilter.category = value; return this; }; /** * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values, * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}). * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value, * they will never collide. * * @method Raycaster.Ray#setCollisionCategory * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {number} value - Unique group index. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCollisionGroup(value) { this.body.collisionFilter.group = value; return this; }; /** * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA &amp; maskB) !== 0` * and `(categoryB &amp; maskA) !== 0` are both true.* * * @method Raycaster.Ray#setCollidesWith * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {(number|number[])} categories - A unique category bitfield, or an array of them. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setCollidesWith(categories) { var flags = 0; if (!Array.isArray(categories)) { flags = categories; } else { for (var i = 0; i &lt; categories.length; i++) { flags |= categories[i]; } } this.body.collisionFilter.mask = flags; return this; }; /** * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object. * * This does not change the bodies collision category, group or filter. Those must be set in addition * to the callback. * * @method Raycaster.Ray#setOnCollide * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {function} callback - The callback to invoke when this body starts colliding with another. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setOnCollide(callback) { let self = this; this.body.onCollideCallback = function(collisionInfo) { if(collisionInfo.rayCollided) { callback(collisionInfo); } else if(self.processOverlap(collisionInfo)) { collisionInfo.rayCollided = true; callback(collisionInfo); } }; return this; }; /** * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object. * * This does not change the bodies collision category, group or filter. Those must be set in addition * to the callback. * * @method Raycaster.Ray#setOnCollideEnd * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {function} callback - The callback to invoke when this body stops colliding with another. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setOnCollideEnd(callback) { this.body.onCollideEndCallback = function(collisionInfo) { if(collisionInfo.rayCollided) { collisionInfo.rayCollided = false; callback(collisionInfo); } } return this; }; /** * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object. * * This does not change the bodies collision category, group or filter. Those must be set in addition * to the callback. * * @method Raycaster.Ray#setOnCollideActive * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {function} callback - The callback to invoke for the duration of this body colliding with another. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setOnCollideActive(callback) { let self = this; let func = function(collisionInfo) { if(self.processOverlap(collisionInfo)) { let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA; if(collisionInfo.rayCollided !== true) { collisionInfo.rayCollided = true; if(self.body.onCollideCallback) { self.body.onCollideCallback(collisionInfo); } if(self.body.onCollideWith !== undefined &amp;&amp; self.body.onCollideWith[body.id]) { self.body.onCollideWith[body.id](body, collisionInfo); } } if(callback) callback(collisionInfo); } else { if(self.body.onCollideEndCallback &amp;&amp; collisionInfo.rayCollided === true) { self.body.onCollideEndCallback(collisionInfo); } } } this.body.onCollideActiveCallback = func; return this; } /** * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object. * * This does not change the bodies collision category, group or filter. Those must be set in addition * to the callback. * * @method Raycaster.Ray#setOnCollideWith * @memberof Raycaster.Ray * @instance * @since 0.9.1 * * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with. * @param {function} callback - The callback to invoke when this body collides with the given body or bodies. * * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance */ export function setOnCollideWith(body, callback) { let self = this; let func = function(body, collisionInfo) { if(collisionInfo.rayCollided) { callback(body, collisionInfo); } else if(self.processOverlap(collisionInfo)) { collisionInfo.rayCollided = true; callback(body, collisionInfo); } } if (!Array.isArray(body)) { body = [ body ]; } for (var i = 0; i &lt; body.length; i++) { var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i]; this.body.setOnCollideWith(src, func); } return this; }; × Search results Close Phaser-raycaster "},"map_map-core.js.html":{"id":"map_map-core.js.html","title":"Source: map/map-core.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/map-core.js /** * @classdesc * * Map class responsible for mapping game objects. * * @namespace Raycaster.Map * @class Raycaster.Map * @constructor * @since 0.6.0 * * @param {object} options - Map specific configuration settings. * @param {Raycaster} [raycaster] - Parent raycaster object. */ export function Map(options, raycaster) { /** * Reference to parent Raycaster object. * * @name Raycaster.Map#_raycaster * @type {Raycaster} * @private * @since 0.9.0 */ this._raycaster = raycaster ? raycaster : false; /** * Mapped object's type * * @name Raycaster.Map#type * @type {string} * @readonly * @since 0.6.0 */ this.type; /** * If set true, map will be tested by ray. Otherwise it will be ignored. * * @name Raycaster.Map#active * @type {boolean} * @default true * @since 0.7.2 */ this.active; /** * If set true, map will be automatically updated on scene update event. * * @name Raycaster.Map_dynamic * @type {boolean} * @default false * @since 0.6.0 */ this._dynamic = false; /** * If set true, map will be treated by ray as circle. Set automaticalyy on map update. * * @name Raycaster.Map#circle * @type {boolean} * @default false * @since 0.9.0 */ this.circle = false; /** * Reference to mapped object. * * @name Raycaster.Map#object * @type {object} * @readonly * @since 0.6.0 */ this.object; /** * Array of mapped object's vertices used as rays targets. * * @name Raycaster.Map#_points * @type {array} * @private * @since 0.6.0 */ this._points = []; /** * Array of mapped object's segments used to test object's intersection with ray. * * @name Raycaster.Map#_segments * @type {array} * @private * @since 0.6.0 */ this._segments = []; /** * Get array of mapped object's vertices used as rays targets. * * @method Raycaster.Map#getPoints * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Point[]} Array of mapped object's vertices. */ this.getPoints; /** * Get array of mapped object's segments used to test object's intersection with ray. * * @method Raycaster.Map#getSegments * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Line[]} Array of mapped object's segments. */ this.getSegments; /** * Get mapped object's bounding box. * * @method Raycaster.Map#getBoundingBox * @memberof Raycaster.Map * @instance * @since 0.9.0 * * @return {Phaser.Geom.Rectangle} Mapped object's bounding box. */ this.getBoundingBox; /** * Update object's map of points and segments. * * @method Raycaster.Map#updateMap * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ this.updateMap; this.config(options); if(!this.notSupported) this.updateMap(); return this; }; Map.prototype = { config: require('./config.js').config, destroy: require('./destroy.js').destroy, get dynamic() { return this._dynamic; }, set dynamic(dynamic) { if(this._dynamic == dynamic) return this; if(dynamic) { this._dynamic = true; //add object to raycaster's dynamic objects list if(this._raycaster) { this._raycaster.dynamicMappedObjects.push(this.object); this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length; this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic; } } else { this._dynamic = false; //remove object from reycasters' dynamic objects list if(this._raycaster) { let index = this._raycaster.dynamicMappedObjects.indexOf(this.object); if(index &gt;= 0) this._raycaster.dynamicMappedObjects.splice(index, 1); this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length; this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic; } } return this; } }; Map.prototype.constructor = Map; × Search results Close Phaser-raycaster "},"map_config.js.html":{"id":"map_config.js.html","title":"Source: map/config.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/config.js let rectangle = require('./map-rectangle-methods.js'); let line = require('./map-line-methods.js'); let polygon = require('./map-polygon-methods.js'); let arc = require('./map-circle-methods.js'); let container = require('./map-container-methods.js'); let tilemap = require('./map-tilemap-methods.js'); let matterBody = require('./map-matterBody-methods.js'); let segmentCount = require('./segmentsCount.js'); let boundingBox = require('./boundingBox.js'); /** * Configure map. * * @method Raycaster.Map#config * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {object} [options] - Map's congfiguration options. May include: * @param {object} options.object - Game object to map * @param {string} [options.type] - Map type. If not defined, it will be determined based on object. * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event). * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated). * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped. * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies. * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies. * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function config(options) { this.object = options.object; //object type if(options.type === undefined) options.type = options.object.type; if(options.type === 'body' || options.type === 'composite') options.type = 'MatterBody'; this.type = options.type; switch(options.type) { case 'Polygon': this.getPoints = polygon.getPoints; this.getSegments = polygon.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = polygon.updateMap; break; case 'Arc': //circle segments count this.segmentCount = (options.segmentCount) ? options.segmentCount : 0; this.circle = (options.segmentCount) ? false : true; this.getPoints = arc.getPoints; this.getSegments = arc.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = arc.updateMap; this.setSegmentCount = segmentCount.setSegmentCount; break; case 'Line': this.getPoints = line.getPoints; this.getSegments = line.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = line.updateMap; break; case 'Container': //container's child this.mapChild = (options.mapChild) ? options.mapChild : null; //circle segments count this.segmentCount = (options.segmentCount) ? options.segmentCount : 0; //transformed container's circle children this._circles = []; this.getPoints = container.getPoints; this.getSegments = container.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = container.updateMap; this._updateChildMap = container._updateChildMap; this.setSegmentCount = segmentCount.setSegmentCount; break; case 'StaticTilemapLayer': //ray colliding tiles this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : []; this.getPoints = tilemap.getPoints; this.getSegments = tilemap.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = tilemap.updateMap; this.setCollisionTiles = tilemap.setCollisionTiles; //reset tilemap origin this.object.setOrigin(0,0); break; case 'DynamicTilemapLayer': //ray colliding tiles this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : []; this.getPoints = tilemap.getPoints; this.getSegments = tilemap.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = tilemap.updateMap; this.setCollisionTiles = tilemap.setCollisionTiles; //reset tilemap origin this.object.setOrigin(0,0); break; case 'TilemapLayer': //ray colliding tiles this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : []; this.getPoints = tilemap.getPoints; this.getSegments = tilemap.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = tilemap.updateMap; this.setCollisionTiles = tilemap.setCollisionTiles; //reset tilemap origin this.object.setOrigin(0,0); break; case 'MatterBody': //force convex body (hull) mapping this.forceConvex = (options.forceConvex) ? true : false; //force mapping by vertices this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false; this.circle = false; this.getPoints = matterBody.getPoints; this.getSegments = matterBody.getSegments; this.getBoundingBox = matterBody.getBoundingBox; this.updateMap = matterBody.updateMap; break; default: this.getPoints = rectangle.getPoints; this.getSegments = rectangle.getSegments; this.getBoundingBox = boundingBox.getBoundingBox; this.updateMap = rectangle.updateMap; } //if object is not supported if(this.type != 'MatterBody' &amp;&amp; typeof this.object.getBounds !== 'function') { this.notSupported = true; } //dynamic map this.dynamic = (options.dynamic == true) ? true : false; //enable/disable map this.active = (options.active !== undefined) ? options.active : true; return this; } × Search results Close Phaser-raycaster "},"map_segmentsCount.js.html":{"id":"map_segmentsCount.js.html","title":"Source: map/segmentsCount.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/segmentsCount.js /** * Set segment count for cirle's map. * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. * * @method Raycaster.Map#setSegmentCount * @memberof Raycaster.Map * @instance * @since 0.6.0 * * @param {number} count - Circle map's segment count. * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function setSegmentCount(count) { this.segmentCount = count; this.circle = count ? false : true; this.updateMap(); return this; } × Search results Close Phaser-raycaster "},"map_map-tilemap-methods.js.html":{"id":"map_map-tilemap-methods.js.html","title":"Source: map/map-tilemap-methods.js","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Source: map/map-tilemap-methods.js /*Map methods for tilemaps*/ /** * Get array of mapped tilemap's vertices used as rays targets. * * @method Raycaster.Map#tilemap.getPoints * @memberof Raycaster.Map * @instance * @private * @since 0.7.3 * * @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Point[]} - Array of mapped object's vertices. */ export function getPoints(ray = false) { if(!this.active) return []; if(!ray || ray &amp;&amp; (ray.detectionRange == 0 || ray.detectionRange &gt;= Phaser.Math.MAX_SAFE_INTEGER)) return this._points; let points = []; for(let point of this._points) { if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) &lt;= ray.detectionRange) points.push(point); } //get intersections between tilemap's segments and ray's detection range edge let segments = this.getSegments(ray); for(let segment of segments) { if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) &gt; ray.detectionRange) points.push(new Phaser.Geom.Point(segment.x1, segment.y1)); if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) &gt; ray.detectionRange) points.push(new Phaser.Geom.Point(segment.x2, segment.y2)); } return points; }; /** * Get array of mapped tilemap's segments used to test object's intersection with ray. * * @method Raycaster.Map#tilemap.getSegments * @memberof Raycaster.Map * @instance * @private * @since 0.7.3 * * @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps. * * @return {Phaser.Geom.Line[]} - Array of mapped object's segments. */ export function getSegments(ray = false) { if(!this.active) return []; if(!ray || (ray &amp;&amp; (ray.detectionRange == 0 || ray.detectionRange &gt;= Phaser.Math.MAX_SAFE_INTEGER))) return this._segments; let segments = []; for(let segment of this._segments) { if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) { segments.push(segment); } } return segments; }; /** * Update tilemap's map of points and segments. * * @method Raycaster.Map#tilemap.updateMap * @memberof Raycaster.Map * @instance * @private * @since 0.7.3 * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function updateMap() { if(!this.active) return this; let points = [], segments = [], columns = Array(this.object.layer.data[0].length + 1); for(let i = 0, iLength = columns.length; i &lt; iLength; i++) { columns[i] = []; } //calculate offset based on object position and origin point let offset = new Phaser.Geom.Point(this.object.x, this.object.y); let row = this.object.layer.data[0], tileWidth = this.object.layer.tileWidth * this.object.scaleX, tileHeight = this.object.layer.tileHeight * this.object.scaleY, startPoint, endPoint; //set top horizontal lines if(this.collisionTiles.includes(row[0].index)) { startPoint = new Phaser.Geom.Point(offset.x, offset.y); endPoint = new Phaser.Geom.Point(tileWidth + offset.x, offset.y); columns[0].push(startPoint); } for(let i = 1, iLength = row.length; i &lt; iLength; i++) { let tile = row[i]; if(!this.collisionTiles.includes(tile.index)) { if(startPoint) { startPoint.neighbours = [endPoint]; endPoint.neighbours = [startPoint]; points.push(startPoint, endPoint); segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)); columns[i].push(endPoint); startPoint = false; endPoint = false; } continue; } let x = i * tileWidth + offset.x, y = offset.y; if(!startPoint) { startPoint = new Phaser.Geom.Point(x, y); columns[i].push(startPoint); } if(!endPoint) { endPoint = new Phaser.Geom.Point(x + tileWidth, y); } else { endPoint.x = x + tileWidth; } } if(startPoint) { startPoint.neighbours = [endPoint]; endPoint.neighbours = [startPoint]; points.push(startPoint, endPoint); segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)); columns[row.length].push(endPoint); } startPoint = false; endPoint = false; for(let i = 1, iLength = this.object.layer.data.length - 1; i &lt; iLength; i++) { row = this.object.layer.data[i]; let higherRow = this.object.layer.data[i - 1]; if(this.collisionTiles.includes(row[0].index) != this.collisionTiles.includes(higherRow[0].index)) { startPoint = new Phaser.Geom.Point(offset.x, i * tileHeight + offset.y); endPoint = new Phaser.Geom.Point(tileWidth + offset.x, i * tileHeight + offset.y); columns[0].push(startPoint); } for(let j = 1, jLength = row.length; j &lt; jLength; j++) { let tile = row[j], isCollisionTile = this.collisionTiles.includes(tile.index), isCollisionHigherTile = this.collisionTiles.includes(higherRow[j].index); if(isCollisionTile == isCollisionHigherTile) { if(startPoint) { startPoint.neighbours = [endPoint]; endPoint.neighbours = [startPoint]; points.push(startPoint, endPoint); segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)); columns[j].push(endPoint); startPoint = false; endPoint = false; } continue; } let x = j * tileWidth + offset.x, y = i * tileHeight + offset.y; if(!startPoint) { startPoint = new Phaser.Geom.Point(x, y); columns[j].push(startPoint); } if(!endPoint) { endPoint = new Phaser.Geom.Point(x + tileWidth, y); } else { endPoint.x = x + tileWidth; } } if(startPoint) { startPoint.neighbours = [endPoint]; endPoint.neighbours = [startPoint]; points.push(startPoint, endPoint); segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)); columns[row.length].push(endPoint); } startPoint = false; endPoint = false; } //set bottom horizontal lines row = this.object.layer.data.slice(-1)[0]; let y = this.object.layer.data.length * tileHeight + offset.y; if(this.collisionTiles.includes(row[0].index)) { startPoint = new Phaser.Geom.Point(offset.x, y); endPoint = new Phaser.Geom.Point(tileWidth + offset.x, y); columns[0].push(startPoint); } for(let i = 1, iLength = row.length; i &lt; iLength; i++) { let tile = row[i]; if(!this.collisionTiles.includes(tile.index)) { if(startPoint) { startPoint.neighbours = [endPoint]; endPoint.neighbours = [startPoint]; points.push(startPoint, endPoint); segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)); columns[i].push(endPoint); startPoint = false; endPoint = false; } continue; } let x = i * tileWidth + offset.x; if(!startPoint) { startPoint = new Phaser.Geom.Point(x, y); columns[i].push(startPoint); } if(!endPoint) { endPoint = new Phaser.Geom.Point(x + tileWidth, y); } else { endPoint.x = x + tileWidth; } } if(startPoint) { startPoint.neighbours = [endPoint]; endPoint.neighbours = [startPoint]; points.push(startPoint, endPoint); segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y)); columns[row.length].push(endPoint); } //set vertical lines for(let i = 0, iLength = columns.length; i &lt; iLength; i++) { const column = columns[i]; for(let j = 0, jLength = column.length - 1; j &lt; jLength; j++) { segments.push(new Phaser.Geom.Line(column[j].x, column[j].y, column[j+1].x, column[j+1].y)); column[j].neighbours.push(column[j+1]); column[j+1].neighbours.push(column[j]); j++; } } this._points = points; this._segments = segments; return this; }; /** * Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only). * * @method Raycaster.Map#setCollisionTiles * @memberof Raycaster.Map * @instance * @since 0.7.3 * * @param {array} [tiles = []] - Set of tile's indexes to map. * * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance */ export function setCollisionTiles(tiles = []) { this.collisionTiles = tiles; return this; } × Search results Close Phaser-raycaster "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Classes Classes Raycaster Ray Map × Search results Close Phaser-raycaster "},"index.html":{"id":"index.html","title":"Index","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Phaser Raycaster Raycasting plugin for Phaser 3. Phaser Raycaster is a Phaser 3 plugin which provide raycasting for geometric game objects, sprites, Arcade Physics and Matter.js bodies. Documentation: https://wiserim.github.io/phaser-raycaster/ Code examples are available on CodePen: LINK Features: compatible with arcade and matter physics, raycasting in a single direction, 360 degrees circle or in a cone, visibility detection (collision detection with game objects), test rays on mapped game objects (containers, lines, rectangles, polygons, circles, sprites, tilemaps and matter bodies), provides closest intersection points between rays and tested objects, tests can be made on all mapped objects, selected ones or only ones within detection range, static and dynamic mapping for individual objects, mapped objects intersections detection, debug mode. NPM npm install phaser-raycaster CDN https://www.jsdelivr.com/package/npm/phaser-raycaster Getting started 1. Include plugin in your project: &lt;!--CDN--&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/phaser-raycaster@0.10.10/dist/phaser-raycaster.min.js\"&gt;&lt;/script&gt; # NPM npm install phaser-raycaster 2. Enable plugin in your Game config: import PhaserRaycaster from 'phaser-raycaster' let config = { type: Phaser.Auto, parent: 'game', width: 800, height: 600, backgroundColor: \"black\", scene: [ Scene1 ], plugins: { scene: [ { key: 'PhaserRaycaster', plugin: PhaserRaycaster, mapping: 'raycasterPlugin' } ] } } new Phaser.Game(config); 3. Create new raycaster in your scene: create() { this.raycaster = this.raycasterPlugin.createRaycaster(options); // additional code } If you're using TypeScript, you need to add to scene plugin class: import PhaserRaycaster from 'phaser-raycaster' export default class MyScene extends Phaser.Scene { raycasterPlugin: PhaserRaycaster // aditional code } 4. Create new ray create() { // additional code this.ray = this.raycaster.createRay(); // additional code } 5. Map game objects which will be tested by rays //create game object this.rectangle = this.add.rectangle(100, 100, 50, 50) .setStrokeStyle(1, 0xff0000); //map game object this.raycaster.mapGameObjects(this.rectangle); //create group this.group = this.add.group(); //map game objects actually in group this.raycaster.mapGameObjects(this.group.getChildren()); //map tilemap layer this.map = this.make.tilemap(); this.tilemap = this.map.createStaticLayer(); this.raycaster.mapGameObjects(this.tilemap, false, { collisionTiles: [1,2,3] //array of tiles types which can collide with ray }); 6. Cast ray //set ray position this.ray.setOrigin(400, 300); //set ray direction (in radians) this.ray.setAngle(2); //set ray direction (in degrees) this.ray.setAngleDeg(90); //cast single ray and get closets intersection, hit mapped object and hit segment let intersection = this.ray.cast(); let hitObject = intersection.object; let hitSegment = intersection.segment; //cast rays in all directions (toward all mapped objects vertices / points) let intersections = this.ray.castCircle(); //set ray's cone angle (in radians) this.ray.setCone(1); //set ray's cone angle (in degrees) this.ray.setConeDeg(90); //cast rays in a cone let intersections = this.ray.castCone(); 7. Raycaster bounding box By default Raycaster is setting it's bounding box based on Arcade Physics / Matter physics world bounds. If world size will change after creation of Raycaster, bounding box needs to be updated. //define bounds var bounds = new Phaser.Geom.Rectangle(x, y, width, height); //get world bounds (arcade physics) bounds = this.worldLayer.getBounds(); //get bounds (matter physics) let walls = this.matter.world; bounds = new Phaser.Geom.Rectangle( walls.top.vertices[3].x, //x walls.top.vertices[3].y, //y walls.bottom.vertices[1].x - walls.top.vertices[3].x, //width walls.bottom.vertices[1].y - walls.top.vertices[3].y //height ) //set bounding box on raycaster creation var raycaster = this.raycasterPlugin.createRaycaster({ boundingBox: bounds }); //set bounding box after creation raycaster.setBoundingBox(x, y, width, height); 8. Collisions (arcade physics) //enable auto slicing field of view this.ray.autoSlice = true; //enable arcade physics body this.ray.enablePhysics(); //set collision (field of view) range this.ray.setCollisionRange(200); //cast ray this.ray.castCircle(); //get all game objects in field of view (which bodies overlap ray's field of view) let visibleObjects = this.ray.overlap(); //get objects in field of view visibleObjects = this.ray.overlap(group.getChildren()); //check if object is in field of view visibleObjects = this.ray.overlap(gameObject); //add overlap collider (require passing ray.processOverlap as process callback) this.physics.add.overlap(this.ray, targets, function(rayFoVCircle, target){ /* * What to do with game objects in line of sight. */ }, this.ray.processOverlap.bind(this.ray)); 9. Collisions (matter physics) //enable auto slicing field of view this.ray.autoSlice = true; //enable matter physics body this.ray.enablePhysics('matter'); //cast ray this.ray.castCircle(); //get all game objects and bodies in field of view (which bodies overlap ray's field of view) let visibleObjects = this.ray.overlap(); //get objects and bodies in field of view visibleObjects = this.ray.overlap([gameObject1, gameObject2, body1, body2]); //check if object or body is in field of view visibleObjects = this.ray.overlap(gameObject); //add onCollide event this.ray.setOnCollide(function(collisionInfo){ //get body let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA; /* * What to do with game object which enters line of sight . */ } }); //add onCollideWith event this.ray.setOnCollideWith(body, function(body, collisionInfo){ /* * What to do with game object which enters line of sight. */ } }); //add onCollideEnd event this.ray.setOnCollideEnd(function(collisionInfo){ //get body let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA; /* * What to do with game object which leaves line of sight. */ } }); //add onCollideActive event this.ray.setOnCollide(function(collisionInfo){ //get body let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA; /* * What to do with game object while it's in line of sight. */ } }); 10. Destroy objects //remove mapped objects this.raycaster.removeMappedObjects(object); this.raycaster.removeMappedObjects(arrayOfObjects); //destroy ray this.ray.destroy(); //destroy raycaster this.raycaster.destroy(); 11. Statistics //get raycaster statistics let statistics = this.raycaster.getStats(); /* statistics = { mappedObjects: { total - mapped objects total static - static maps dynamic - dynamic maps rectangleMaps - rectangle maps polygonMaps - polygon maps circleMaps - circle maps lineMaps - line maps containerMaps - container maps tilemapMaps - tilemap maps matterMaps - matter body maps } } */ //get ray statistics let rayStatistics = this.ray.getStats(); /* rayStatistics = { method - used casting method (cast, castCircle, castCone) rays - casted rays testedMappedObjects - tested mapped objects hitMappedObjects - hit mapped objects segments - tested segments time - casting time } */ 12. Debug mode //enable debug mode this.raycaster = this.raycasterPlugin.createRaycaster({ debug: true }); //advanced debug mode options this.raycaster = this.raycasterPlugin.createRaycaster({ debug: { enabled: false, //enable debug mode maps: true, //enable maps debug rays: true, //enable rays debug graphics: { ray: 0x00ff00, //debug ray color; set false to disable rayPoint: 0xff00ff, //debug ray point color; set false to disable mapPoint: 0x00ffff, //debug map point color; set false to disable mapSegment: 0x0000ff, //debug map segment color; set false to disable mapBoundingBox: 0xff0000 //debug map bounding box color; set false to disable } } }); //change debug options after initialization this.raycaster.debugOptions.enabled = true; this.raycaster.setOptions({ debug: true }); × Search results Close Phaser-raycaster "},"Raycaster.html":{"id":"Raycaster.html","title":"Class: Raycaster","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Class: Raycaster Raycaster Raycaster class responsible for creating ray objects and managing mapped objects. new Raycaster( [options]) Parameters: Name Type Argument Description options object &lt;optional&gt; Raycaster's configuration options. May include: Properties Name Type Argument Default Description scene Phaser.Scene &lt;optional&gt; Scene in which Raycaster will be used. mapSegmentCount number &lt;optional&gt; 0 Number of segments of circle maps. If set to 0, map will be teste objects object | Array.&lt;object&gt; &lt;optional&gt; Game object or array of game objects to map. boundingBox Phaser.Geom.Rectangle &lt;optional&gt; Raycaster's bounding box. If not passed, Raycaster will set it's bounding box based on Arcade Physics / Matter physics world bounds. autoUpdate boolean &lt;optional&gt; true If set true, automatically update dynamic maps on scene update event. debug boolean | object &lt;optional&gt; Enable debug mode or configure it debugOptions. Since: 0.6.0 Source: raycaster-core.js, line 7 Classes Ray Map Members &lt;readonly&gt; version :string Plugin version. Type: string Since: 0.6.0 Source: raycaster-core.js, line 26 debugOptions :Object Raycaster's debug config Type: Object Properties: Name Type Argument Default Description enable boolean &lt;optional&gt; false Enable debug mode maps boolean &lt;optional&gt; true Enable maps debug graphics boolean Debug graphics options Properties Name Type Argument Default Description ray boolean | number &lt;optional&gt; 0x00ff00 Debug ray color. Set false to disable. rayPoint boolean | number &lt;optional&gt; 0xff00ff Debug ray point color. Set false to disable. mapPoint boolean | number &lt;optional&gt; 0x00ffff debug map point color. Set false to disable. mapSegment boolean | number &lt;optional&gt; 0x0000ff Debug map segment color. Set false to disable. mapBoundingBox boolean | number &lt;optional&gt; 0xff0000 Debug map bounding box color. Set false to disable. Since: 0.10.0 Source: raycaster-core.js, line 53 mappedObjects :Array.&lt;object&gt; Array of mapped game objects. Type: Array.&lt;object&gt; Since: 0.6.0 Source: raycaster-core.js, line 129 dynamicMappedObjects :Array.&lt;object&gt; Array of dynamic mapped game objects. Type: Array.&lt;object&gt; Since: 0.10.6 Source: raycaster-core.js, line 137 mapSegmentCount :number Number of segments of circle maps. Type: number Since: 0.6.0 Default Value: 0 Source: raycaster-core.js, line 145 &lt;static&gt; Map_dynamic :boolean If set true, map will be automatically updated on scene update event. Type: boolean Since: 0.6.0 Default Value: false Source: map/map-core.js, line 42 Methods setOptions( [options]) Configure raycaster. Parameters: Name Type Argument Description options object &lt;optional&gt; Raycaster's congfiguration options. May include: Properties Name Type Argument Default Description scene Phaser.Scene &lt;optional&gt; Scene in which Raycaster will be used. mapSegmentCount number &lt;optional&gt; 0 Number of segments of circle maps. objects object | Array.&lt;object&gt; &lt;optional&gt; Game object or array of game objects to map. boundingBox Phaser.Geom.Rectangle &lt;optional&gt; Raycaster's bounding box. debug boolean | object &lt;optional&gt; Enable debug mode or cofigure debugOptions. Since: 0.6.0 Source: raycaster-core.js, line 187 Returns: Raycaster instance Type Raycaster setBoundingBox(x, y, width, height) Set Raycaster's bounding box. Parameters: Name Type Description x number The X coordinate of the top left corner of bounding box. y number The Y coordinate of the top left corner of bounding box. width number The width of bounding box. height number The height of bounding box. Since: 0.6.0 Source: raycaster-core.js, line 230 Returns: Raycaster instance Type Raycaster mapGameObjects(objects [, dynamic] [, options]) Map game objects Parameters: Name Type Argument Default Description objects object | Array.&lt;object&gt; Game object / matter body or array of game objects / matter bodies to map. dynamic boolean &lt;optional&gt; false Raycaster.Map dynamic flag (determines map will be updated automatically). options object &lt;optional&gt; Additional options for Raycaster.Map Since: 0.6.0 Source: raycaster-core.js, line 270 Returns: Raycaster instance Type Raycaster removeMappedObjects(objects) Remove game object's Raycaster.Map maps. Parameters: Name Type Description objects object | Array.&lt;object&gt; Game object or array of game objects which maps will be removed. Since: 0.6.0 Source: raycaster-core.js, line 362 Returns: Raycaster instance Type Raycaster enableMaps(objects) Enable game object's Raycaster.Map maps. Parameters: Name Type Description objects object | Array.&lt;object&gt; Game object or array of game objects which maps will be enabled. Since: 0.7.2 Source: raycaster-core.js, line 437 Returns: Raycaster instance Type Raycaster disableMaps(objects) Disable game object's Raycaster.Map maps. Parameters: Name Type Description objects object | Array.&lt;object&gt; Game object or array of game objects which maps will be disabled. Since: 0.7.2 Source: raycaster-core.js, line 470 Returns: Raycaster instance Type Raycaster update() Updates all Raycaster.Map dynamic maps. Fired on Phaser.Scene update event. Since: 0.6.0 Source: raycaster-core.js, line 503 Returns: Raycaster instance Type Raycaster createRay( [options]) Create Raycaster.Ray object. Parameters: Name Type Argument Description options object &lt;optional&gt; Ray's congfiguration options. May include: Properties Name Type Argument Default Description origin Phaser.Geom.Point | Point &lt;optional&gt; {x:0, y:0} Ray's position. angle number &lt;optional&gt; 0 Ray's angle in radians. angleDeg number &lt;optional&gt; 0 Ray's angle in degrees. cone number &lt;optional&gt; 0 Ray's cone angle in radians. coneDeg number &lt;optional&gt; 0 Ray's cone angle in degrees. range number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. collisionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's maximum collision range of ray's field of view. detectionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Maximum distance between ray's position and tested objects bounding boxes. ignoreNotIntersectedRays boolean &lt;optional&gt; true If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. autoSlice boolean &lt;optional&gt; false If set true, ray will automatically slice intersections into array of triangles and store it in Ray.slicedIntersections. round boolean &lt;optional&gt; false If set true, point where ray hit will be rounded. enablePhysics boolean | 'arcade' | 'matter' &lt;optional&gt; false Add to ray physics body. Body will be a circle with radius equal to Ray.collisionRange. If set true, arcade physics body will be added. Since: 0.6.0 Source: raycaster-core.js, line 542 Returns: Raycaster.Ray instance Type Raycaster.Ray getStats() Get raycaster statistics. Since: 0.10.0 Source: raycaster-core.js, line 570 Returns: Raycaster statistics. Type object destroy() Destroy object and all mapped objects. Since: 0.10.3 Source: raycaster-core.js, line 642 × Search results Close Phaser-raycaster "},"Raycaster.Ray.html":{"id":"Raycaster.Ray.html","title":"Class: Ray","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Class: Ray Raycaster. Ray Ray class responsible for casting ray's and testing their collisions with mapped objects. new Ray( [options] [, raycaster]) Parameters: Name Type Argument Description options object &lt;optional&gt; Ray's congfiguration options. May include: Properties Name Type Argument Default Description origin Phaser.Geom.Point | Point &lt;optional&gt; {x:0, y:0} Ray's position. angle number &lt;optional&gt; 0 Ray's angle in radians. angleDeg number &lt;optional&gt; 0 Ray's angle in degrees. cone number &lt;optional&gt; 0 Ray's cone angle in radians. coneDeg number &lt;optional&gt; 0 Ray's cone angle in degrees. range number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. collisionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's maximum collision range of ray's field of view. detectionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Maximum distance between ray's position and tested objects bounding boxes. ignoreNotIntersectedRays boolean &lt;optional&gt; true If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. autoSlice boolean &lt;optional&gt; false If set true, ray will automatically slice intersections into array of triangles and store it in Ray.slicedIntersections. round boolean &lt;optional&gt; false If set true, point where ray hit will be rounded. enablePhysics boolean | 'arcade' | 'matter' &lt;optional&gt; false Add to ray physics body. Body will be a circle with radius equal to Ray.collisionRange. If set true, arcade physics body will be added. raycaster Raycaster &lt;optional&gt; Parent raycaster object. Since: 0.6.0 Source: ray/ray-core.js, line 1 Members origin :Phaser.Geom.Point Ray's source position. Type: Phaser.Geom.Point Since: 0.6.0 Source: ray/ray-core.js, line 36 angle :number Ray's angle in radians. Type: number Since: 0.6.0 Default Value: 0 Source: ray/ray-core.js, line 53 cone :number Ray's cone width angle in radians. Type: number Since: 0.7.0 Default Value: 0 Source: ray/ray-core.js, line 62 rayRange :number Ray's maximum range Type: number Since: 0.6.0 Default Value: Phaser.Math.MAX_SAFE_INTEGER Source: ray/ray-core.js, line 71 detectionRange :number Ray's maximum detection range. Objects outside detection range won't be tested. Ray tests all objects when set to 0. Type: number Since: 0.6.0 Source: ray/ray-core.js, line 80 collisionRange :number Ray's maximum collision range of ray's field of view. Radius of Ray.body. Type: number Since: 0.8.0 Default Value: Phaser.Math.MAX_SAFE_INTEGER Source: ray/ray-core.js, line 99 ignoreNotIntersectedRays :boolean If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. Type: boolean Since: 0.6.0 Default Value: true Source: ray/ray-core.js, line 108 round :boolean If set true, ray's hit points will be rounded. Type: boolean Since: 0.8.1 Default Value: false Source: ray/ray-core.js, line 117 autoSlice :boolean If set true, ray will automatically slice intersections into array of triangles and store it in Ray.slicedIntersections. Type: boolean Since: 0.8.0 Default Value: false Source: ray/ray-core.js, line 126 intersections :Array.&lt;object&gt; Array of intersections from last raycast representing field of view. Type: Array.&lt;object&gt; Since: 0.8.0 Default Value: [] Source: ray/ray-core.js, line 135 slicedIntersections :Array.&lt;Phaser.Geom.Triangle&gt; Array of triangles representing slices of field of view from last raycast. Type: Array.&lt;Phaser.Geom.Triangle&gt; Since: 0.8.0 Default Value: [] Source: ray/ray-core.js, line 144 body :object Physics body for testing field of view collisions. Type: object Since: 0.8.0 Default Value: undefined Source: ray/ray-core.js, line 154 bodyType :boolean|'arcade'|'matter' Physics body type. Type: boolean | 'arcade' | 'matter' Since: 0.9.0 Default Value: false Source: ray/ray-core.js, line 163 Methods config( [options]) Configure ray. Parameters: Name Type Argument Description options object &lt;optional&gt; Ray's congfiguration options. May include: Properties Name Type Argument Default Description origin Phaser.Geom.Point | Point &lt;optional&gt; {x:0, y:0} Ray's position. angle number &lt;optional&gt; 0 Ray's angle in radians. angleDeg number &lt;optional&gt; 0 Ray's angle in degrees. cone number &lt;optional&gt; 0 Ray's cone angle in radians. coneDeg number &lt;optional&gt; 0 Ray's cone angle in degrees. range number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. collisionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's maximum collision range of ray's field of view. detectionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Maximum distance between ray's position and tested objects bounding boxes. ignoreNotIntersectedRays boolean &lt;optional&gt; true If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position. autoSlice boolean &lt;optional&gt; false If set true, ray will automatically slice intersections into array of triangles and store it in Ray.slicedIntersections. round boolean &lt;optional&gt; false If set true, point where ray hit will be rounded. enablePhysics boolean | 'arcade' | 'matter' &lt;optional&gt; false Add to ray physics body. Body will be a circle with radius equal to Ray.collisionRange. If set true, arcade physics body will be added. Since: 0.6.0 Source: ray/config.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray cast( [options]) Cast ray to find closest intersection with tested mapped objects. Parameters: Name Type Argument Description options object &lt;optional&gt; options that may include: Properties Name Type Argument Default Description objects Array.&lt;object&gt; &lt;optional&gt; {Raycaster#mappedObjects} Array of game objects to test. If not provided test all mapped game objects. target Phaser.Geom.Point | Point &lt;optional&gt; Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point. internal boolean &lt;optional&gt; false Flag determining if method is used by other casting method. Since: 0.6.0 Source: ray/cast.js, line 1 Returns: Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available. Type Phaser.Geom.Point | boolean castCircle( [options]) Cast ray in all directions to find closest intersections with tested mapped objects. Parameters: Name Type Argument Description options object &lt;optional&gt; options that may include: Properties Name Type Argument Default Description objects Array.&lt;object&gt; &lt;optional&gt; Raycaster.mappedObjects Array of game objects to test. If not provided test all mapped game objects. Since: 0.6.0 Source: ray/castCircle.js, line 1 Returns: Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available. Type Array.&lt;Phaser.Geom.Point&gt; castCone( [options]) Cast ray in a cone to find closest intersections with tested mapped objects. Parameters: Name Type Argument Description options object &lt;optional&gt; options that may include: Properties Name Type Argument Default Description objects Array.&lt;object&gt; &lt;optional&gt; Raycaster.mappedObjects Array of game objects to test. If not provided test all mapped game objects. Since: 0.7.0 Source: ray/castCone.js, line 1 Returns: Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available. Type Array.&lt;Phaser.Geom.Point&gt; setRay(x, y [, angle] [, range]) Set ray's position, direction (angle) and range. Parameters: Name Type Argument Default Description x number X coordinate. y number Y coordinate. angle number &lt;optional&gt; Ray's angle in radians. range number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. Since: 0.6.0 Source: ray/ray.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setOrigin(x, y) Set ray's source position. Parameters: Name Type Description x number X coordinate. y number Y coordinate. Since: 0.6.0 Source: ray/origin.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setAngle( [angle]) Set ray's angle (direction) in radians. Parameters: Name Type Argument Default Description angle number &lt;optional&gt; 0 Ray's angle in radians. Since: 0.6.0 Source: ray/angle.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setAngleDeg( [angle]) Set ray's angle (direction) in degrees. Parameters: Name Type Argument Default Description angle number &lt;optional&gt; 0 Ray's angle in degrees. Since: 0.6.1 Source: ray/angle.js, line 19 Returns: Raycaster.Ray instance Type Raycaster.Ray setRayRange( [rayRange]) Set ray's range. Parameters: Name Type Argument Default Description rayRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's range. Since: 0.6.0 Source: ray/range.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setDetectionRange( [detectionRange]) Set ray's maximum detection range. Objects outside detection range won't be tested. Ray tests all objects when set to 0. Parameters: Name Type Argument Default Description detectionRange number &lt;optional&gt; 0 Maximum distance between ray's position and tested objects bounding boxes. Since: 0.6.0 Source: ray/range.js, line 19 Returns: Raycaster.Ray instance Type Raycaster.Ray setCollisionRange( [collisionRange]) Set ray's field of view maximum collision range. Objects outside collision range won't be tested by Raycaster.Ray.overlap method. Determines ray's physics body radius. Parameters: Name Type Argument Default Description collisionRange number &lt;optional&gt; Phaser.Math.MAX_SAFE_INTEGER Ray's collision range and physics body radius. Since: 0.8.0 Source: ray/range.js, line 39 Returns: Raycaster.Ray instance Type Raycaster.Ray boundsInRange(object [, bounds]) Test if object's bounding box is in ray's detection range. Parameters: Name Type Argument Default Description object object Tested object bounds Phaser.Geom.Rectangle | boolean &lt;optional&gt; false Tested object's bounds. If not passed bounds will be generated automatically. Since: 0.6.0 Source: ray/range.js, line 95 Returns: Information if object is in ray's detection range. Type boolean setCone( [cone]) Set ray's cone angle (width) in radians. Parameters: Name Type Argument Default Description cone number &lt;optional&gt; 0 Ray's cone angle in radians. Since: 0.7.0 Source: ray/cone.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setConeDeg( [cone]) Set ray's cone angle (width) in degrees. Parameters: Name Type Argument Default Description cone number &lt;optional&gt; 0 Ray's cone angle in degrees. Since: 0.7.0 Source: ray/cone.js, line 18 Returns: Raycaster.Ray instance Type Raycaster.Ray overlap( [objects]) Get game objects overlaping field of view. Parameters: Name Type Argument Description objects object | Array.&lt;object&gt; &lt;optional&gt; Game object / array off game objects to test. Since: 0.8.0 Source: ray/overlap.js, line 1 Returns: Array of game objects that overlaps with field of view. Type Array.&lt;object&gt; processOverlap(object1, object2) Process callback for physics collider / overlap. Parameters: Name Type Description object1 object Game object or matter body passed by collider / overlap or matter CollisionInfo object. object2 object Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument. Since: 0.8.0 Source: ray/overlap.js, line 103 Returns: Return true if game object is overlapping ray's field of view. Type boolean enablePhysics( [type]) Add to ray physics body. Body will be a circle with radius equal to Ray.collisionRange. Physics body can be added only once. Parameters: Name Type Argument Default Description type 'arcade' | 'matter' &lt;optional&gt; 'arcade' Physics type Since: 0.8.0 Source: ray/enablePhysics.js, line 1 Returns: Raycaster.Ray instance Type Raycaster.Ray setCollisionCategory(value) Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31. Two bodies with different collision groups (see #setCollisionGroup) will only collide if their collision categories are included in their collision masks (see #setCollidesWith). Parameters: Name Type Description value number Unique category bitfield. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 2 Returns: Raycaster.Ray instance Type Raycaster.Ray setCollisionCategory(value) Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values, they will collide according to the usual rules (see #setCollisionCategory and #setCollisionGroup). If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value, they will never collide. Parameters: Name Type Description value number Unique group index. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 22 Returns: Raycaster.Ray instance Type Raycaster.Ray setCollidesWith(categories) Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA &amp; maskB) !== 0` and `(categoryB &amp; maskA) !== 0` are both true.* Parameters: Name Type Description categories number | Array.&lt;number&gt; A unique category bitfield, or an array of them. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 43 Returns: Raycaster.Ray instance Type Raycaster.Ray setOnCollide(callback) The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object. This does not change the bodies collision category, group or filter. Those must be set in addition to the callback. Parameters: Name Type Description callback function The callback to invoke when this body starts colliding with another. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 78 Returns: Raycaster.Ray instance Type Raycaster.Ray setOnCollideEnd(callback) The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object. This does not change the bodies collision category, group or filter. Those must be set in addition to the callback. Parameters: Name Type Description callback function The callback to invoke when this body stops colliding with another. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 108 Returns: Raycaster.Ray instance Type Raycaster.Ray setOnCollideActive(callback) The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object. This does not change the bodies collision category, group or filter. Those must be set in addition to the callback. Parameters: Name Type Description callback function The callback to invoke for the duration of this body colliding with another. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 134 Returns: Raycaster.Ray instance Type Raycaster.Ray setOnCollideWith(body, callback) The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object. This does not change the bodies collision category, group or filter. Those must be set in addition to the callback. Parameters: Name Type Description body MatterJS.Body | Array.&lt;MatterJS.Body&gt; The body, or an array of bodies, to test for collisions with. callback function The callback to invoke when this body collides with the given body or bodies. Since: 0.9.1 Source: ray/matter-physics-methods.js, line 180 Returns: Raycaster.Ray instance Type Raycaster.Ray × Search results Close Phaser-raycaster "},"Raycaster.Map.html":{"id":"Raycaster.Map.html","title":"Class: Map","body":" Phaser-raycaster Classes RaycasterRaycaster.RayRaycaster.Map Class: Map Raycaster. Map Map class responsible for mapping game objects. new Map(options [, raycaster]) Parameters: Name Type Argument Description options object Map specific configuration settings. raycaster Raycaster &lt;optional&gt; Parent raycaster object. Since: 0.6.0 Source: map/map-core.js, line 1 Members &lt;readonly&gt; type :string Mapped object's type Type: string Since: 0.6.0 Source: map/map-core.js, line 24 active :boolean If set true, map will be tested by ray. Otherwise it will be ignored. Type: boolean Since: 0.7.2 Default Value: true Source: map/map-core.js, line 33 circle :boolean If set true, map will be treated by ray as circle. Set automaticalyy on map update. Type: boolean Since: 0.9.0 Default Value: false Source: map/map-core.js, line 51 &lt;readonly&gt; object :object Reference to mapped object. Type: object Since: 0.6.0 Source: map/map-core.js, line 60 Methods getPoints( [ray]) Get array of mapped object's vertices used as rays targets. Parameters: Name Type Argument Description ray Raycaster.Ray &lt;optional&gt; Raycaster.Ray object used in some some types of maps. Since: 0.6.0 Source: map/map-core.js, line 87 Returns: Array of mapped object's vertices. Type Array.&lt;Phaser.Geom.Point&gt; getSegments( [ray]) Get array of mapped object's segments used to test object's intersection with ray. Parameters: Name Type Argument Description ray Raycaster.Ray &lt;optional&gt; Raycaster.Ray object used in some some types of maps. Since: 0.6.0 Source: map/map-core.js, line 100 Returns: Array of mapped object's segments. Type Array.&lt;Phaser.Geom.Line&gt; getBoundingBox() Get mapped object's bounding box. Since: 0.9.0 Source: map/map-core.js, line 113 Returns: Mapped object's bounding box. Type Phaser.Geom.Rectangle updateMap() Update object's map of points and segments. Since: 0.6.0 Source: map/map-core.js, line 124 Returns: Raycaster.Map instance Type Raycaster.Map config( [options]) Configure map. Parameters: Name Type Argument Description options object &lt;optional&gt; Map's congfiguration options. May include: Properties Name Type Argument Default Description object object Game object to map type string &lt;optional&gt; Map type. If not defined, it will be determined based on object. dynamic boolean &lt;optional&gt; false If set true, map will be dynamic (updated on scene update event). active boolean &lt;optional&gt; true If set true, map will be active (will provide points, segments and will be updated). segmentCount number &lt;optional&gt; Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. mapChild object &lt;optional&gt; Container's child. If set, only set child will be mapped. forceConvex boolean &lt;optional&gt; If set true, matter body map will use convex body (hull) for non-covex bodies. forceVerticesMapping boolean &lt;optional&gt; If set true, matter body map will use only vertices for mapping circle bodies. Since: 0.6.0 Source: map/config.js, line 11 Returns: Raycaster.Map instance Type Raycaster.Map setSegmentCount(count) Set segment count for cirle's map. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray. Parameters: Name Type Description count number Circle map's segment count. Since: 0.6.0 Source: map/segmentsCount.js, line 1 Returns: Raycaster.Map instance Type Raycaster.Map setCollisionTiles( [tiles]) Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only). Parameters: Name Type Argument Default Description tiles array &lt;optional&gt; [] Set of tile's indexes to map. Since: 0.7.3 Source: map/map-tilemap-methods.js, line 295 Returns: Raycaster.Map instance Type Raycaster.Map × Search results Close Phaser-raycaster "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
